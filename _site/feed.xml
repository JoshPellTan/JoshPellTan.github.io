<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Josh Pell'Page</title>
    <description>When you think you can stop learning, is a time when you are going to be washed out.</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 23 Dec 2016 15:03:38 +0800</pubDate>
    <lastBuildDate>Fri, 23 Dec 2016 15:03:38 +0800</lastBuildDate>
    <generator>Jekyll v3.3.1</generator>
    
      <item>
        <title>Wellcome</title>
        <description>&lt;h3 id=&quot;images-look-great-too&quot;&gt;Images look great, too&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/DMCHDqF.jpg&quot; alt=&quot;Thumper&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 16 Dec 2016 16:08:08 +0800</pubDate>
        <link>http://localhost:4000/hello/2016/12/16/Wellcome/</link>
        <guid isPermaLink="true">http://localhost:4000/hello/2016/12/16/Wellcome/</guid>
        
        <category>demo</category>
        
        <category>Hello, Lao Tie!</category>
        
        
        <category>Hello</category>
        
      </item>
    
      <item>
        <title>RunTime方法交换</title>
        <description>&lt;p&gt;现在我有个这种需求：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[UIImage imageNamed:@&quot;img1&quot;];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这个方法在图片不存在是会引起崩溃，这里先提供两种简单点的方法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;继承&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (UIImage *)imageNamed:(NSString *)name {

    // 恢复系统做法
    UIImage *image = [super imageNamed:name];
    if ( image == nil ) {
        NSLog(@&quot;加载失败&quot;);
    }
    return image;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;就是创建一个UIImage的子类，用子类的&lt;code class=&quot;highlighter-rouge&quot;&gt;imageNamed:&lt;/code&gt;方法加载图片&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;分类&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;分类方法挺好，简洁。切记，方法名不能重复系统方法名，可以加个前缀&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (UIImage *)TJ_imageNamed:(NSString *)name {

    // 恢复系统做法
    UIImage *image = [UIImage imageNamed:name];
    if ( image == nil ) {
        NSLog(@&quot;加载失败&quot;);
    }
    return image;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;大家看到这儿发现与我们的runtime还没半毛钱关系，稍安勿躁。现在需求变这样：一个项目，已经开发迭代两年，以前都是用UIImage加载图片，但现在项目老大要我们dui这个空图片的崩溃问题进行处理，一看看上面两个方法，懵逼中。。。。。。工程量太大，灯灯灯等！runtime登场：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;流程&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;提供分类&lt;/li&gt;
  &lt;li&gt;写一个有这样功能的方法&lt;/li&gt;
  &lt;li&gt;用这个方法跟系统方法进行方法交换&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;分类中的新方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (void)load {

    // 获取类方法
    // class:获取哪个类的方法
    // SEL:获取哪
    Method imageNameMethod = class_getClassMethod(self, @selector(imageNamed:));
    Method bj_imageNameMethod = class_getClassMethod(self, @selector(TJ_imageNamed:));

    // 交换方法的实现
    method_exchangeImplementations(imageNameMethod, bj_imageNameMethod);
}

+ (UIImage *)bj_imageNamed:(NSString *)name {

    UIImage *image = [UIImage bj_imageNamed:name];

    if (image == nil) {
        NSLog(@&quot;加载失败！\n&quot;);
    }

    return image;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;主线程直接调用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[UIImage imageNamed:@&quot;img1&quot;];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;方法交换示意图：
&lt;img src=&quot;http://pic.yupoo.com/joshpell/G5XK4VgE/rDp9G.png&quot; alt=&quot;Thumper&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 12 Dec 2016 16:08:08 +0800</pubDate>
        <link>http://localhost:4000/study/2016/12/12/RunTime%E6%96%B9%E6%B3%95%E4%BA%A4%E6%8D%A2/</link>
        <guid isPermaLink="true">http://localhost:4000/study/2016/12/12/RunTime%E6%96%B9%E6%B3%95%E4%BA%A4%E6%8D%A2/</guid>
        
        <category>runtime</category>
        
        <category>方法交换</category>
        
        <category>RunTime方法交换</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>RunTime动态添加方法和属性</title>
        <description>&lt;p&gt;###1.动态添加方法
面试的时候面试官可能会问用过performSelector方法么，那就请注意了，他百分之百问的是跟runtime有关的知识，不要傻乎乎的以为他就是问你有没有用过这个方法了，然后你还跟他扯可以延迟调用方法啥的，这些都是OC封装好的，相信我他不是在考你这个。&lt;/p&gt;

&lt;p&gt;performSelector方法区别于直接调用，直接调用时假如你方法没实现，编译直接报错，而performSelector只会报警告，所以人家是问你runtime动态添加方法的东西。&lt;/p&gt;

&lt;p&gt;动态添加方法是一个很有意义的事情，因为程序在编译的时候，会把所有的方法加到一个方法列表中，但是我们并不是所有的方法都会使用到，耗时耗力。我们应该多利用懒加载的方式，用到某个方法，再添加，不用的方法就不用管它。&lt;/p&gt;

&lt;p&gt;首先我们需要导入#import &amp;lt;objc/message.h&amp;gt;，然后写下下面2个方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 当某个类方法只声明，没有实现的时候，会执行下面的方法
+ (BOOL)resolveClassMethod:(SEL)sel;
// 当某个对象方法没有只声明，没有实现的时候，会执行下面的方法。
+ (BOOL)resolveInstanceMethod:(SEL)sel ;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们先创建一个函数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void eat(id self, SEL _cmd,id param1){
    NSLog(@&quot;调用%@---%@---%@&quot;,self,NSStringFromSelector(_cmd),param1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;讲解一下，每一个函数，都有2个默认的隐式参数，一个是谁调用了自己，一个是SEL，SEL就是对方法的一种包装。包装的SEL类型数据它对应相应的方法地址,找到方法地址就可以调用方法。后面的id类型的param1是我写的一个参数，因为是C语言的函数，我们无法创建NS之类的类型，这里我就用id类型来接参数。&lt;/p&gt;

&lt;p&gt;接下来，根据官方文档我们可以添加下面的代码做判断，使得在找不到eat方法的时候，可以执行我们动态添加的eat方法，注意，上面的函数名可以随意写，只需要在下面添加方法的时候做好关联就好：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 外界调用一个没有实现的对象方法-
// resolveInstanceMethod中sel是没有实现的参数
+ (BOOL)resolveInstanceMethod:(SEL)sel{

    NSLog(@&quot;%@&quot;,NSStringFromSelector(sel));
//    if (sel == @selector(eat)) {}这句话等同下面的判断

    if ([NSStringFromSelector(sel) isEqualToString:@&quot;eat:&quot;] ) {
        // 这里添加方法
        // 给哪个类
        //SEL:方法名
        //IMP:方法的实现（函数的入口-函数的指针-函数的名）
        //type :方法类型
        class_addMethod(self, sel, (IMP)eat, &quot;v@:@&quot;); 
        returnYES;
    }
    return [super resolveInstanceMethod:sel];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里介绍一下OBJC_EXPORT BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)这个函数的参数意义&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Class cls:就是你给哪个类添加的这个方法
SEL name：就是方法名字是啥，默认进入方法的时候，肯定是方法上带的参数sel没有，所以我们这里传入的是sel。
(IMP)eat：这里需要我们传入一个IMP，啥实IMP,IMP就是方法的实现（函数的入口-函数的指针-函数的名）大家这里意会下
 const char *types，这里我们可以好好说一说。我先说下意思，*v@:@*的意思就是，返回类型是void,参数是id,SEL,id。具体大家参考上面我写的函数以及函数说明。

如果想查到这些代表啥意思，可以打开苹果文档，输入Type Encodings，选择我箭头所指。查询。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/joshpell/G5YKO1rz/BI7j7.png&quot; alt=&quot;Thumper&quot; /&gt;&lt;/p&gt;

&lt;p&gt;###2.动态添加属性
通过运行时添加属性，使用面还是比较广的。比如想给button类绑定一个属性，大家肯定会继承button来操作。其实通过运行时添加属性，我们就可以实现给系统button添加一个属性的需求。&lt;/p&gt;

&lt;p&gt;默认我们在创建分类的时候，添加一个成员属性后，大家往往会发现，直接调用这个类的点语法，我们获取不了属性,为什么呢？&lt;/p&gt;

&lt;p&gt;因为默认分类创建的属性，不会执行set和get方法。如果我们一定要获取到这个属性，我们应该怎么做呢？这里有2种方法，一种就是添加一个静态变量，重写它的set和get方法.另外一种就是通过运行时，添加这个属性。这里我只讲第二种，代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 声明一个char型的key
static char nameKey;

- (void)setName:(NSString *)name
{
    // 属性跟对象有关联-就是添加属性

    // object:对象
    // key:属性名，根据key去获取到值
    // value:值
    // policy：策略
    objc_setAssociatedObject(self, &amp;amp;nameKey, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里我讲一下OBJC_EXPORT void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)这个方法。&lt;/p&gt;

&lt;p&gt;这个方法的字面意思就是把一个值，通过一个key绑定到一个类中，最后设置一下保存的策略。代码的意思是，把name的值，通过nameKey绑定到当前类，保存的是nonatomic的copy类型。
补充一下最后一个参数（策略）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// assign类型
   OBJC_ASSOCIATION_ASSIGN = 0,
// 非原子性Retain--&amp;gt;相当于Strong
    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1,
// 非原子性 copy-
    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,
// 原子性Retain
    OBJC_ASSOCIATION_RETAIN = 01401,
// 原子性copy
    OBJC_ASSOCIATION_COPY
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;取得动态绑定属性的方法如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (NSString *)name
{
    return objc_getAssociatedObject(self, &amp;amp;nameKey);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;简单的解释就是通过self这个类的，nameKey这个key,我们就可以取到nameKey相对应的值了。这就是如何通过runtime来动态的给类添加属性了，帅哥，你可以试试了！&lt;/p&gt;

</description>
        <pubDate>Mon, 12 Dec 2016 16:08:08 +0800</pubDate>
        <link>http://localhost:4000/study/2016/12/12/RunTime%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7/</link>
        <guid isPermaLink="true">http://localhost:4000/study/2016/12/12/RunTime%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7/</guid>
        
        <category>runtime</category>
        
        <category>动态添加</category>
        
        <category>RunTime动态添加方法和属性</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>emoji表情作为单字符长度的处理</title>
        <description>&lt;p&gt;我们知道emoji表情是一些特殊格式的字符串，因此我们在计算其长度的时候直接用“xxx.length”即可，但有时候产品经理会要求你把所有的emoji表情都当做一个字符处理，别问我怎么知道的😭😭😭，这里写下来希望大家不要跟我一样到处跳坑&lt;/p&gt;

&lt;p&gt;还是直接上代码&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;获取emoji个数（我这里写到了NSString的类方法中）&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
+ (NSInteger)emojiCountInString:(NSString *)string
{
    __block NSInteger num = 0;
    [string enumerateSubstringsInRange:NSMakeRange(0, [string length])
                               options:NSStringEnumerationByComposedCharacterSequences
                            usingBlock:^(NSString * _Nullable substring, NSRange substringRange, NSRange enclosingRange, BOOL * _Nonnull stop) {
		const unichar hs = [substring characterAtIndex:0];
		if (0xd800 &amp;lt;= hs &amp;amp;&amp;amp; hs &amp;lt;= 0xdbff){
			if (substring.length &amp;gt; 1) {
				const unichar ls = [substring characterAtIndex:1];
			    const int uc = ((hs - 0xd800) * 0x400) + (ls - 0xdc00) + 0x10000;
				if (0x1d000 &amp;lt;= uc &amp;amp;&amp;amp; uc &amp;lt;= 0x1f918)
				{
					num += 1;
				}
			}
		}
		else if (substring.length &amp;gt; 1)
		{
			const unichar ls = [substring characterAtIndex:1];
			if (ls == 0x20e3 || ls == 0xFE0F || ls == 0xd83c)
			{
				num += 1;
			}
		}
	    else{
		// non surrogate
			if (0x2100 &amp;lt;= hs &amp;amp;&amp;amp; hs &amp;lt;= 0x27ff)
			{
			if (0x278b &amp;lt;= hs &amp;amp;&amp;amp; 0x2792 &amp;gt;= hs)
			{
				//不为emoji
			}
			else
			{
				num += 1;
			}
		}
		else if (0x2B05 &amp;lt;= hs &amp;amp;&amp;amp; hs &amp;lt;= 0x2b07)
		{
			num += 1;
		}
		else if (0x2934 &amp;lt;= hs &amp;amp;&amp;amp; hs &amp;lt;= 0x2935)
		{
			num += 1;
		}
		else if (0x3297 &amp;lt;= hs &amp;amp;&amp;amp; hs &amp;lt;= 0x3299)
		{
			num += 1;
		}
		else if (hs == 0xa9 || hs == 0xae || hs == 0x303d || hs == 0x3030 || hs == 0x2b55 || hs == 0x2b1c || hs == 0x2b1b || hs == 0x2b50 || hs == 0xd83e)
		{
			num += 1;
		}
	}
	}];
    return num;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;字符串去掉emoji&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
+ (NSString *)getStringWithoutEmoji:(NSString *)string
{
    __block NSString *tempStr = string;
    [string enumerateSubstringsInRange:NSMakeRange(0, [string length])
                               options:NSStringEnumerationByComposedCharacterSequences
                            usingBlock:^(NSString * _Nullable substring, NSRange substringRange, NSRange enclosingRange, BOOL * _Nonnull stop) {
                                const unichar hs = [substring characterAtIndex:0];
                                // surrogate pair
                                if (0xd800 &amp;lt;= hs &amp;amp;&amp;amp; hs &amp;lt;= 0xdbff)
                                {
                                    if (substring.length &amp;gt; 1)
                                    {
                                        const unichar ls = [substring characterAtIndex:1];
                                        const int uc = ((hs - 0xd800) * 0x400) + (ls - 0xdc00) + 0x10000;
                                        if (0x1d000 &amp;lt;= uc &amp;amp;&amp;amp; uc &amp;lt;= 0x1f918)
                                        {

                                            tempStr = [tempStr stringByReplacingOccurrencesOfString:substring withString:@&quot;&quot;];
                                        }
                                    }
                                }
                                else if (substring.length &amp;gt; 1)
                                {
                                    const unichar ls = [substring characterAtIndex:1];
                                    if (ls == 0x20e3 || ls == 0xFE0F || ls == 0xd83c)
                                    {
                                        tempStr = [tempStr stringByReplacingOccurrencesOfString:substring withString:@&quot;&quot;];
                                    }
                                }
                                else
                                {
                                    // non surrogate
                                    if (0x2100 &amp;lt;= hs &amp;amp;&amp;amp; hs &amp;lt;= 0x27ff)
                                    {
                                        if (0x278b &amp;lt;= hs &amp;amp;&amp;amp; 0x2792 &amp;gt;= hs)
                                        {
                                            //不为emoji
                                        }
                                        else
                                        {
                                            tempStr = [tempStr stringByReplacingOccurrencesOfString:substring withString:@&quot;&quot;];
                                        }
                                    }
                                    else if (0x2B05 &amp;lt;= hs &amp;amp;&amp;amp; hs &amp;lt;= 0x2b07)
                                    {
                                        tempStr = [tempStr stringByReplacingOccurrencesOfString:substring withString:@&quot;&quot;];
                                    }
                                    else if (0x2934 &amp;lt;= hs &amp;amp;&amp;amp; hs &amp;lt;= 0x2935)
                                    {
                                        tempStr = [tempStr stringByReplacingOccurrencesOfString:substring withString:@&quot;&quot;];
                                    }
                                    else if (0x3297 &amp;lt;= hs &amp;amp;&amp;amp; hs &amp;lt;= 0x3299)
                                    {
                                        tempStr = [tempStr stringByReplacingOccurrencesOfString:substring withString:@&quot;&quot;];
                                    }
                                    else if (hs == 0xa9 || hs == 0xae || hs == 0x303d || hs == 0x3030 || hs == 0x2b55 || hs == 0x2b1c || hs == 0x2b1b || hs == 0x2b50 || hs == 0xd83e)
                                    {
                                        tempStr = [tempStr stringByReplacingOccurrencesOfString:substring withString:@&quot;&quot;];
                                    }
                                }
                            }];
    return tempStr;
}



&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;获取把emoji表情当成单个字符长度处理后的字符串长度&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-(NSInteger)lengthWithEmojiString{
    NSInteger emojiLen = [NSString emojiCountInString:self];
    NSString * normalStr = [NSString getStringWithoutEmoji:self];
    NSInteger strLengh = normalStr.length+emojiLen;
    return strLengh;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 08 Nov 2016 16:08:08 +0800</pubDate>
        <link>http://localhost:4000/study/2016/11/08/emoji%E8%A1%A8%E6%83%85%E4%BD%9C%E4%B8%BA%E5%8D%95%E5%AD%97%E7%AC%A6%E9%95%BF%E5%BA%A6%E7%9A%84%E5%A4%84%E7%90%86/</link>
        <guid isPermaLink="true">http://localhost:4000/study/2016/11/08/emoji%E8%A1%A8%E6%83%85%E4%BD%9C%E4%B8%BA%E5%8D%95%E5%AD%97%E7%AC%A6%E9%95%BF%E5%BA%A6%E7%9A%84%E5%A4%84%E7%90%86/</guid>
        
        <category>emoji</category>
        
        <category>长度</category>
        
        <category>emoji表情作为单字符长度的处理</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>block中weakSelf和strongSelf的简化</title>
        <description>&lt;p&gt;我们知道在block中使用全局变量需要考虑到循环引用问题，这时就会引入weakSelf和strongSelf，具体用法不多说，网上很多介绍的文章，比如&lt;a href=&quot;http://www.jianshu.com/p/701da54bd78c&quot;&gt;深入研究Block用weakSelf、strongSelf、@weakify、@strongify解决循环引用&lt;/a&gt;
  但是频繁的书写weakSelf和strongSelf会让人觉得代码重复，但是这个东西又不好抽取。经过多方打探，找到一个特别简便的方法，你不用再考虑weakSelf和strongSelf的书写，直接使用self代替即可。在文件中加入下面的宏即可。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define weakify(...) \
    ext_keywordify \
    metamacro_foreach_cxt(ext_weakify_,, __weak, __VA_ARGS__)
#define strongify(...) \
    ext_keywordify \
    _Pragma(&quot;clang diagnostic push&quot;) \
    _Pragma(&quot;clang diagnostic ignored \&quot;-Wshadow\&quot;&quot;) \
    metamacro_foreach(ext_strongify_,, __VA_ARGS__) \
    _Pragma(&quot;clang diagnostic pop&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 18 Oct 2016 16:08:08 +0800</pubDate>
        <link>http://localhost:4000/efficiency/2016/10/18/block%E4%B8%ADweakSelf%E5%92%8CstrongSelf%E7%9A%84%E7%AE%80%E5%8C%96/</link>
        <guid isPermaLink="true">http://localhost:4000/efficiency/2016/10/18/block%E4%B8%ADweakSelf%E5%92%8CstrongSelf%E7%9A%84%E7%AE%80%E5%8C%96/</guid>
        
        <category>循环引用</category>
        
        <category>block</category>
        
        <category>self</category>
        
        <category>block中weakSelf和strongSelf的简化</category>
        
        
        <category>Efficiency</category>
        
      </item>
    
      <item>
        <title>OC升序与降序排列数组</title>
        <description>&lt;p&gt;对数组进行快速升降序排列,话不多说直接上代码&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;升序&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSArray *tMlist = @[@4,@5,@2,@6,@3,@7,@8];
NSArray *tArray = [tMlist sortedArrayUsingComparator:^NSComparisonResult(id obj1, id obj2) {
     NSNumber *tNumber1 = (NSNumber *)obj1;
     NSNumber *tNumber2 = (NSNumber *)obj2; //升序2，4，。。
     if ([tNumber1 integerValue] &amp;lt; [tNumber2 integerValue]){
          return NSOrderedAscending;
     }else{
          return NSOrderedDescending;
     }
}];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;降序&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSArray *tMlist = @[@4,@5,@2,@6,@3,@7,@8];
NSArray *tArray = [tMlist sortedArrayUsingComparator:^NSComparisonResult(id obj1, id obj2) {
     NSNumber *tNumber1 = (NSNumber *)obj1;
     NSNumber *tNumber2 = (NSNumber *)obj2; //降序序8，7，。。
     if ([tNumber1 integerValue] &amp;lt; [tNumber2 integerValue]){
          return NSOrderedDescending;
     }else{
          return NSOrderedAscending;
     }
}];

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 18 Oct 2016 16:08:08 +0800</pubDate>
        <link>http://localhost:4000/efficiency/2016/10/18/OC%E5%8D%87%E5%BA%8F%E4%B8%8E%E9%99%8D%E5%BA%8F%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84/</link>
        <guid isPermaLink="true">http://localhost:4000/efficiency/2016/10/18/OC%E5%8D%87%E5%BA%8F%E4%B8%8E%E9%99%8D%E5%BA%8F%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84/</guid>
        
        <category>oc排序</category>
        
        <category>升序降序</category>
        
        <category>OC升序与降序排列数组</category>
        
        
        <category>Efficiency</category>
        
      </item>
    
      <item>
        <title>cornerstone永久破解</title>
        <description>&lt;p&gt;有截图就不码蚊子了😁&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/joshpell/G5Qw8sv9/Qvlnf.png&quot; alt=&quot;Thumper&quot; /&gt;
&lt;img src=&quot;http://pic.yupoo.com/joshpell/G5Qw8GrN/qLFGC.png&quot; alt=&quot;Thumper&quot; /&gt;
&lt;img src=&quot;http://pic.yupoo.com/joshpell/G5Qw8A6m/SFQ1X.png&quot; alt=&quot;Thumper&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 14 Oct 2016 16:08:08 +0800</pubDate>
        <link>http://localhost:4000/tips/2016/10/14/cornerstone%E6%B0%B8%E4%B9%85%E7%A0%B4%E8%A7%A3/</link>
        <guid isPermaLink="true">http://localhost:4000/tips/2016/10/14/cornerstone%E6%B0%B8%E4%B9%85%E7%A0%B4%E8%A7%A3/</guid>
        
        <category>cornerstone</category>
        
        <category>破解</category>
        
        <category>cornerstone永久破解</category>
        
        
        <category>tips</category>
        
      </item>
    
      <item>
        <title>代码的特殊注释</title>
        <description>&lt;p&gt;用“///”和“#param mark”来给代码做注释很常见，下面介绍几个不常见的注释方法，中高级程序员必备！&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;TODO: + 说明：
如果代码中有该标识，说明在标识处有功能代码待编写，待实现的功能在说明中会简略说明。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;FIXME: + 说明：
如果代码中有该标识，说明标识处代码需要修正，甚至代码是错误的，不能工作，需要修复，如何修正会在说明中简略说明。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;XXX: + 说明：
如果代码中有该标识，说明标识处代码虽然实现了功能，但是实现的方法有待商榷，希望将来能改进，要改进的地方会在说明中简略说明。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;eclipse中特殊的注释：
在eclipse中，TODO、FIXME和XXX都会被eclipse的task视图所收集。在项目发布前，检查一下task视图是一个很好的习惯。此外，在eclipse中，我们可自定义自己的特殊注释标签。如在C/C++中，进入window—&amp;gt;preferences—&amp;gt;C/C++—&amp;gt;Task Tags窗口即可添加特殊标签，默认只有TODO、FIXME和XXX。&lt;/p&gt;

</description>
        <pubDate>Sun, 09 Oct 2016 16:08:08 +0800</pubDate>
        <link>http://localhost:4000/tips/2016/10/09/%E4%BB%A3%E7%A0%81%E7%9A%84%E7%89%B9%E6%AE%8A%E6%B3%A8%E9%87%8A/</link>
        <guid isPermaLink="true">http://localhost:4000/tips/2016/10/09/%E4%BB%A3%E7%A0%81%E7%9A%84%E7%89%B9%E6%AE%8A%E6%B3%A8%E9%87%8A/</guid>
        
        <category>代码规范</category>
        
        <category>特殊注释</category>
        
        <category>OC代码的特殊注释</category>
        
        
        <category>tips</category>
        
      </item>
    
      <item>
        <title>常用正则表达式</title>
        <description>&lt;ul&gt;
  &lt;li&gt;验证用户名和密码：&lt;code class=&quot;highlighter-rouge&quot;&gt;^[a-zA-Z]/w{5,15}$&lt;/code&gt;正确格式：”[A-Z][a-z]_[0-9]”组成,并且第一个字必须为字母6~16位；&lt;/li&gt;
  &lt;li&gt;验证电话号码：&lt;code class=&quot;highlighter-rouge&quot;&gt;^(//d{3,4}-)//d{7,8}$&lt;/code&gt;正确格式：xxx/xxxx-xxxxxxx/xxxxxxxx；&lt;/li&gt;
  &lt;li&gt;验证手机号码：&lt;code class=&quot;highlighter-rouge&quot;&gt;^1[34578][0-9]//d{8}$&lt;/code&gt;;&lt;/li&gt;
  &lt;li&gt;验证身份证号（15位或18位数字）：&lt;code class=&quot;highlighter-rouge&quot;&gt;//d{14}[[0-9],0-9xX]&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;验证Email地址:(&lt;code class=&quot;highlighter-rouge&quot;&gt;^//w+([-+.]//w+)*@//w+([-.]//w+)*/.//w+([-.]//w+)*$&lt;/code&gt;);&lt;/li&gt;
  &lt;li&gt;只能输入由数字和26个英文字母组成的字符串：(&lt;code class=&quot;highlighter-rouge&quot;&gt;^[A-Za-z0-9]+$&lt;/code&gt;) ;&lt;/li&gt;
  &lt;li&gt;整数或者小数：^[0-9]+([.]{0,1}[0-9]+){0,1}$&lt;/li&gt;
  &lt;li&gt;只能输入数字：&lt;code class=&quot;highlighter-rouge&quot;&gt;^[0-9]*$&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;只能输入n位的数字：&lt;code class=&quot;highlighter-rouge&quot;&gt;^//d{n}$&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;只能输入至少n位的数字：&lt;code class=&quot;highlighter-rouge&quot;&gt;^//d{n,}$&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;只能输入m~n位的数字：&lt;code class=&quot;highlighter-rouge&quot;&gt;^//d{m,n}$&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;只能输入某个数字开头：&lt;code class=&quot;highlighter-rouge&quot;&gt;^(0*)$&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;只能输入有两位小数的正实数：&lt;code class=&quot;highlighter-rouge&quot;&gt;^[0-9]+(.[0-9]{2})?$&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;只能输入有1~3位小数的正实数：&lt;code class=&quot;highlighter-rouge&quot;&gt;^[0-9]+(/.[0-9]{1,3})?$&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;只能输入非零的正整数：&lt;code class=&quot;highlighter-rouge&quot;&gt;^/+?[1-9][0-9]*$&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;只能输入非零的负整数：&lt;code class=&quot;highlighter-rouge&quot;&gt;^/-[1-9][]0-9&lt;/code&gt;*$。&lt;/li&gt;
  &lt;li&gt;只能输入长度为3的字符：&lt;code class=&quot;highlighter-rouge&quot;&gt;^.{3}$&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;只能输入由26个英文字母组成的字符串：&lt;code class=&quot;highlighter-rouge&quot;&gt;^[A-Za-z]+$&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;只能输入由26个大写英文字母组成的字符串：&lt;code class=&quot;highlighter-rouge&quot;&gt;^[A-Z]+$&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;只能输入由26个小写英文字母组成的字符串：&lt;code class=&quot;highlighter-rouge&quot;&gt;^[a-z]+$&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;验证是否含有^%&amp;amp;’,;=?$/等字符：&lt;code class=&quot;highlighter-rouge&quot;&gt;[^%&amp;amp;',;=?$/x22]+&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;只能输入汉字：&lt;code class=&quot;highlighter-rouge&quot;&gt;^[/u4e00-/u9fa5]{0,}$&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;验证URL：&lt;code class=&quot;highlighter-rouge&quot;&gt;^http://([//w-]+/.)+[//w-]+(/[//w-./?%&amp;amp;=]*)?$&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;验证一年的12个月：&lt;code class=&quot;highlighter-rouge&quot;&gt;^(0?[1-9]1[0-2])$&lt;/code&gt;正确格式为：”01”～”09”和”10”～”12”&lt;/li&gt;
  &lt;li&gt;验证一个月的31天：&lt;code class=&quot;highlighter-rouge&quot;&gt;^((0?[1-9])|((1|2)[0-9])|30|31)$&lt;/code&gt;正确格式为；”01”～”09”、”10”～”29”和“30”~“31”。&lt;/li&gt;
  &lt;li&gt;获取日期正则表达式：&lt;code class=&quot;highlighter-rouge&quot;&gt;//d{4}[年|/-|/.]//d{/1-/12}[月|/-|/.]//d{/1-/31}日?&lt;/code&gt;
评注：可用来匹配大多数年月日信息。&lt;/li&gt;
  &lt;li&gt;匹配双字节字符(包括汉字在内)：&lt;code class=&quot;highlighter-rouge&quot;&gt;[^/x00-/xff]&lt;/code&gt;
评注：可以用来计算字符串的长度（一个双字节字符长度计+2，ASCII字符计1）&lt;/li&gt;
  &lt;li&gt;匹配空白行的正则表达式：&lt;code class=&quot;highlighter-rouge&quot;&gt;/n/s*/r&lt;/code&gt;
评注：可以用来删除空白行&lt;/li&gt;
  &lt;li&gt;匹配HTML标记的正则表达式：&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;(/S*?)[^&amp;gt;]*&amp;gt;.*?|&amp;lt;.*? /&amp;gt;&lt;/code&gt;
评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力&lt;/li&gt;
  &lt;li&gt;匹配首尾空白字符的正则表达式：&lt;code class=&quot;highlighter-rouge&quot;&gt;^/s*|/s*$&lt;/code&gt;
评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式&lt;/li&gt;
  &lt;li&gt;匹配网址URL的正则表达式：&lt;code class=&quot;highlighter-rouge&quot;&gt;[a-zA-z]+://[^/s]*&lt;/code&gt;
评注：网上流传的版本功能很有限，上面这个基本可以满足需求&lt;/li&gt;
  &lt;li&gt;匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：&lt;code class=&quot;highlighter-rouge&quot;&gt;^[a-zA-Z][a-zA-Z0-9_]{4,15}$&lt;/code&gt;
评注：表单验证时很实用&lt;/li&gt;
  &lt;li&gt;匹配腾讯QQ号：&lt;code class=&quot;highlighter-rouge&quot;&gt;[1-9][0-9]/{4,/}&lt;/code&gt;评注：腾讯QQ号从10 000 开始&lt;/li&gt;
  &lt;li&gt;匹配中国邮政编码：&lt;code class=&quot;highlighter-rouge&quot;&gt;[1-9]//d{5}(?!/d)&lt;/code&gt;评注：中国邮政编码为6位数字&lt;/li&gt;
  &lt;li&gt;匹配ip地址：&lt;code class=&quot;highlighter-rouge&quot;&gt;((2[0-4]//d|25[0-5]|[01]?//d//d?)/.){3}(2[0-4]//d|25[0-5]|[01]?//d//d?)&lt;/code&gt;。评注：提取ip地址时有用&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 24 Aug 2016 16:08:08 +0800</pubDate>
        <link>http://localhost:4000/tips/2016/08/24/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
        <guid isPermaLink="true">http://localhost:4000/tips/2016/08/24/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
        
        <category>正则</category>
        
        <category>常用正则表达式</category>
        
        
        <category>tips</category>
        
      </item>
    
      <item>
        <title>界面中有键盘事件时的UI处理</title>
        <description>&lt;ul&gt;
  &lt;li&gt;界面操作的时候经常需要进行输入操作，键盘会有遮挡UI的情况，这是就需要对键盘进行监听，做对应处理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;控制器加入对键盘事件的监听，控制器加入代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[NSNotificationCenter defaultCenter]addObserver:selfselector:@selector(keyboardWillAppear:) name:UIKeyboardWillShowNotification object:nil];
[[NSNotificationCenter defaultCenter]addObserver:selfselector:@selector(keyboardWillDisappear:) name:UIKeyboardWillHideNotification object:nil];	    
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;实现键盘出现和消失的代理并计算键盘高度，按需求操作UI&lt;/p&gt;

    &lt;p&gt;键盘出现和消失&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-(void)keyboardWillAppear:(NSNotification *)notification{

    float keyboardH = [self keyboardEndingFrameHeight:notification.userInfo];
    [UIView animateWithDuration:0.2 animations:^{
    	self.contentView.frame = CGRectMake(0,kDeviceHeight-contentView.height-keyboardH,kDeviceWidth,contentView.height);
    }];
}

-(void)keyboardWillDisappear:(NSNotification *)note {

    self.contentView.frame = CGRectMake(0,kDeviceHeight-contentView.height,kDeviceWidth,contentView.height);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;下面也是最重要的方法，获取键盘高度&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-(CGFloat)keyboardEndingFrameHeight:(NSDictionary *)userInfo {

    CGRect keyboardEndingUncorrectedFrame = [[userInfo objectForKey:UIKeyboardFrameEndUserInfoKey]CGRectValue];

    CGRect keyboardEndingFrame = [selfconvertRect:keyboardEndingUncorrectedFrame fromView:nil];

    return keyboardEndingFrame.size.height;

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Mon, 08 Aug 2016 16:08:08 +0800</pubDate>
        <link>http://localhost:4000/ui/2016/08/08/%E7%95%8C%E9%9D%A2%E4%B8%AD%E6%9C%89%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%E6%97%B6%E7%9A%84UI%E5%A4%84%E7%90%86/</link>
        <guid isPermaLink="true">http://localhost:4000/ui/2016/08/08/%E7%95%8C%E9%9D%A2%E4%B8%AD%E6%9C%89%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%E6%97%B6%E7%9A%84UI%E5%A4%84%E7%90%86/</guid>
        
        <category>iOS</category>
        
        <category>键盘</category>
        
        <category>界面中有键盘事件时的UI处理</category>
        
        
        <category>UI</category>
        
      </item>
    
  </channel>
</rss>
