<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Josh Pell'Page</title>
    <description>When you think you can stop learning, is a time when you are going to be washed out.</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 19 Jan 2017 16:51:52 +0800</pubDate>
    <lastBuildDate>Thu, 19 Jan 2017 16:51:52 +0800</lastBuildDate>
    <generator>Jekyll v3.3.1</generator>
    
      <item>
        <title>关于抱怨和不满</title>
        <description>&lt;p&gt;二十过半的我经常能听到这样的声音：我这工作怎么怎么不好了、当初要是选择那个又怎样怎样了、以后我应该干嘛呢…等等&lt;/p&gt;

&lt;p&gt;确实，我们这个年龄段的绝大部分人仍然是迷茫的。&lt;/p&gt;

&lt;p&gt;许多人的家庭都很普通，没权没钱没势，不可能像国民老公那样先从老爹那儿拿个5亿练练手，又由于父母的社会地位在那儿，遇到事情别人多少都会给点面子，所以比较一下后默默放下了“先赚他一个亿”的小目标。&lt;/p&gt;

&lt;p&gt;但我们这代人基本都受过高等教育，不愿像上一代一样普普通通，总想搞出一番事业（搞事情），却发现不知道第一步怎么走。但在我看来却是我们不敢走这第一步，我们都已成家或将成家，都有家庭，有的已经有了小孩，有几个愿意或者敢放弃那些现在口中的那些不好的工作，放弃一个月几千或者上万的收入，一头扎进一个不知能不能成功抑或不知何时才能成功的创业项目中？相信我们这一代全部都投身创业中，总能成就几个大鳄。&lt;/p&gt;

&lt;p&gt;经常看到这儿一个文章那儿一部视频，都是讲一些成功人士的如何走上成功之路的。但你看看当他们下海加入创业大军时他们是一个什么样的状态，你就不会再这么局促不安了，不是CEO就是CTO，或者就是某国际公司技术核心或者业务核心。这代表什么？代表他们有经验，有技术，有技术，有人脉！比如&lt;a href=&quot;http://baike.baidu.com/view/1240566.htm&quot;&gt;蔡崇信&lt;/a&gt;、&lt;a href=&quot;http://baike.baidu.com/link?url=OXSuqRi80a4MFvxM6brRnpC7UjLvUGJYh1m8MDP_YiWI-xo76wMIoHKUDv8gr6oweepXKCuM-7fUArZRJSrvBzfiE3Wiwxpkphb5wn_iZj7&quot;&gt;雷军&lt;/a&gt;、&lt;a href=&quot;http://baike.baidu.com/link?url=_2UjhZcmVBlUir0E-jqmXw5SZ6J3LlMtE86QPRfczR9P_jlVNeZJhXytS7B4-M-1Z5h4gXWb5s1Iv0XKKNj6jicvBmBKSBA4N5aggqcA4MtkECOCXG8lPKN4vHWdiMCe&quot;&gt;李彦宏&lt;/a&gt;。或许你会说马云，他不就是个老师出身吗？但人家88年做大学老师，那时候大学生都是牛X人，何况大学生的老师，再说，他的口才他的眼界，几个人能比的。所以，他们的成功都是有成功的理由的。&lt;/p&gt;

&lt;p&gt;所以当你对现实不满，对境遇有所抱怨的时候，你应该知道，那都是你自己一步一步选择来的。不要相信什么命运使然，那只是很多不愿意直面自己曾经的错误选择的一个借口而已，跟“我们性格很不合适”一样，都是玄学。你只有在努力提升自己的业务水平或者技术水平，并达到一个比你环境水平更高的一个高度后，你才有资格去想更多。&lt;/p&gt;

&lt;p&gt;这句话送给大家，共勉：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;如果你不知道自己想做什么，就先把身边的事情做好。不知道自己该去哪里，就先走好现在的路。不知道会遇见谁，就先善待身边的所有人，不知道做的事情有没有意义，至少先确定自己有没有去做，不轻易的打搅别人的小幸福，也不嘲笑别人的梦想。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;还年轻的我们，应该学会活在当下，做好眼前的自己，这样你才能在有能力的时候放开去搏。不管最后结果如何，年迈之后你会因为有一个嘴角向上扬起的青春而感恩自己，庆幸能活出自己！&lt;/p&gt;

</description>
        <pubDate>Thu, 19 Jan 2017 16:08:13 +0800</pubDate>
        <link>http://localhost:4000/study/2017/01/19/%E5%85%B3%E4%BA%8E%E6%8A%B1%E6%80%A8%E5%92%8C%E4%B8%8D%E6%BB%A1/</link>
        <guid isPermaLink="true">http://localhost:4000/study/2017/01/19/%E5%85%B3%E4%BA%8E%E6%8A%B1%E6%80%A8%E5%92%8C%E4%B8%8D%E6%BB%A1/</guid>
        
        <category>essay</category>
        
        <category>关于抱怨和不满</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>关于截取app页面长图</title>
        <description>&lt;p&gt;前几天听朋友说他们项目准备加一个功能，就是将页面所有的内容截取出来生成一张长图，我想这是什么需求，有页面分享为嘛要分享长图o(╯□╰)o。后来某天在公司浏览简书的文章的时候无意发现了简书居然有这个功能，然后赶紧打开简书的app，果然app也有这个截长图的功能，事实证明我毕竟不是产品经理的料。后来就开始研究这个东西，查了一些绘图的资料后终于找到方法了，试验后果然可行。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;普通截图&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CALayer&lt;/code&gt;类有个方法&lt;code class=&quot;highlighter-rouge&quot;&gt;renderInContext:&lt;/code&gt;，这个方法用来截取layer层的图像，传入一个图形上下文，最后再通过图形上下文获取图片的方法&lt;code class=&quot;highlighter-rouge&quot;&gt;UIGraphicsGetImageFromCurrentImageContext()&lt;/code&gt;就可以拿到想要截取的图片了，下面就是截取普通图层的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;UIGraphicsBeginImageContextWithOptions(imageSize, YES, 0.0);
[view.layer renderInContext:UIGraphicsGetCurrentContext()];
image = UIGraphicsGetImageFromCurrentImageContext();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;下面来说一下&lt;code class=&quot;highlighter-rouge&quot;&gt;UIGraphicsBeginImageContextWithOptions()&lt;/code&gt;，这个方法作用是开启图形上下文。第一个参数控制截图的大小，一般跟view大小一致，若小于view大小，图片最后会丢失view右边或者下部的一些图像；第二个是透明开关，一般传YES截取的图片质量会高点；第三个参数是缩放因子，一般传1.0，其他的可以自己试试。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;截取长图（这里针对tableView和collectionView）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可能你不信，截取长图跟上面方法一样，只需要在开启图形上下文时将size设置为tableView或collectionView的contentSize即可，并且将tableview滚到顶部再开始截图，代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;UIGraphicsBeginImageContextWithOptions(tableView.contentSize , YES, 0.0);
tableView.contentOffset = CGPointZero;
tableView.frame = CGRectMake(0, 0, tableView.contentSize.width, tableView.contentSize.height);
[tableView.layer renderInContext: UIGraphicsGetCurrentContext()];
image = UIGraphicsGetImageFromCurrentImageContext();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;怎么样很简单吧，你还可以下载我在github上放置的&lt;a href=&quot;https://github.com/JoshPellTan/TJImageCutDemo&quot;&gt;demo&lt;/a&gt;来看看，欢迎star！&lt;/p&gt;
</description>
        <pubDate>Wed, 11 Jan 2017 16:08:13 +0800</pubDate>
        <link>http://localhost:4000/study/2017/01/11/%E5%85%B3%E4%BA%8E%E6%88%AA%E5%8F%96app%E9%A1%B5%E9%9D%A2%E9%95%BF%E5%9B%BE/</link>
        <guid isPermaLink="true">http://localhost:4000/study/2017/01/11/%E5%85%B3%E4%BA%8E%E6%88%AA%E5%8F%96app%E9%A1%B5%E9%9D%A2%E9%95%BF%E5%9B%BE/</guid>
        
        <category>长图</category>
        
        <category>绘图</category>
        
        <category>关于截取app页面长图</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>关于取消网络请求</title>
        <description>&lt;p&gt;今天猛地一下突然想到很久以前遇到的一个面试问题，如果一个网络请求已经发送，但是请求还没有完成，这时我想取消这个请求怎么办？刚刚查了查资料，自己也想了想，下面就从这个需求说起。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;这个需求有何意义？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果说这只是一个单纯地面试题，那么它将毫无意义，那如果不是呢？一个完整的网络请求是由客户端向服务器发起http请求，再由服务器发送responseObject给客户端（中间的其他关于握手传送的数据包我们暂且不论），这就包含了上行流量和下行流量，这些都是会包含在用户总流量中的（说到这儿大家是不是开始有自己的想法了呢？）。如果我们在请求返回之前cancel掉这个网络请求的话，那么客户端会发送一个reset packet来断开当前http连接，阻止后续流量的产生。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;所以,如果不cancel请求，完成之后的回调会找delegate，若是weak引用，Controller被释放后delegate也变为nil，业务流程释放，还算比较安全。但也会浪费用户的一些流量，这也是为什么很多app看着体量小，但是会大量消耗用户流量的原因。而且假如Controller未被释放或者代理不是weak引用，那么回调后的一些后续操作就可能引发一些安全问题。因此，一个较成熟的APP都应该将这种优化APP并且能提高用户体验的优化考虑进去。&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如何实现对请求的取消操作（以常用的AFNetwork为例）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1.取消所有网络操作&lt;/p&gt;

&lt;p&gt;首先拿到AFHTTPSessionManager(注意做成全局单例)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (AFHTTPSessionManager *)manager  
{  
    if (!_manager) {  
        _manager = [AFHTTPSessionManager manager];  
    }  
    return _manager;  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;当需要执行取消所有网络操作时假如下面代码即可&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[self.manager.operationQueue cancelAllOperations]; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;2.取消单个网络操作&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSString *urlStr = @&quot;&quot;;//你的请求url
NSURLSessionTask *task = [manager GET:urlStr parameters:nil progress:^(NSProgress * _Nonnull downloadProgress) {
        
    } success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
        
    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
        
    }];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在你需要执行取消操作的地方假如代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if(self.task) {
	[self.task cancel];//取消当前界面的数据请求.
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;(o゜▽゜)o☆[BINGO!]完成！&lt;/p&gt;
</description>
        <pubDate>Thu, 05 Jan 2017 20:12:29 +0800</pubDate>
        <link>http://localhost:4000/study/2017/01/05/%E5%85%B3%E4%BA%8E%E5%8F%96%E6%B6%88%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/</link>
        <guid isPermaLink="true">http://localhost:4000/study/2017/01/05/%E5%85%B3%E4%BA%8E%E5%8F%96%E6%B6%88%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/</guid>
        
        <category>网络请求</category>
        
        <category>优化</category>
        
        <category>关于取消网络请求</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>iOS开发调试总结</title>
        <description>&lt;p&gt;软件开发工作，调试是必备技能，重要性不多说。而调试方法在不同的平台和语言中大部分都是可以互相迁移借鉴的。不同语言、不同IDE、不同平台的调试，有同性也有个性。本人iOS开发，语言就用OC，IDE就用Xcode，来唠唠开发调试&lt;/p&gt;

&lt;h3 id=&quot;一nslog打印&quot;&gt;一、NSLog打印&lt;/h3&gt;

&lt;p&gt;NSLog打印是最常用的调试方法，也是初学者最喜欢最简单的调试方法，通过打印信息来查看运行路径和数据等。但打印出的信息比较少，NSLog本身效率也较低，但也不失为一种方法。用下面的宏做NSLog的优化，可以打印类名、所在方法名、详细时间和行号等信息。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define JFLog(format, ...) do { \
    fprintf(stderr,&quot;&amp;lt;%s : %d&amp;gt; %s\n&quot;, \
    [[[NSString stringWithUTF8String:__FILE__] lastPathComponent] UTF8String], \
    __LINE__, __func__); \
    (NSLog)((format), ##__VA_ARGS__); \
    fprintf(stderr,&quot;-------\n&quot;); \
} while (0)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;二生命周期方法initdealloc&quot;&gt;二、生命周期方法init、dealloc&lt;/h3&gt;
&lt;p&gt;在ViewController中，有两个生命周期方法我们可以重写，也就是init、dealloc方法。对于监听某些对象的状态很有帮助，特别是在dealloc方法中查看当ViewController退出的时候某个对象有没有release掉。这里也没有啥代码，自己视情况而定。&lt;/p&gt;

&lt;h3 id=&quot;三查看代码运行时间&quot;&gt;三、查看代码运行时间&lt;/h3&gt;
&lt;p&gt;有时候需要做代码优化或者耗时操作，分析效率问题，就需要知道代码的执行时间长短。网上看了看资料，直接使用宏就行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define CODE_START NSDate *startTime = [NSDate date]
#define CODE_END   NSLog(@&quot;Time:%f&quot;,-[startTime timeIntervalSinceNow])
//用法
	CODE_START;
   //放置被监测代码
   CODE_END;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;控制台打印：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/joshpell/G72XQEDV/GRPz7.png =500x20&quot; alt=&quot;Thumper&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;四僵尸对象&quot;&gt;四、僵尸对象&lt;/h3&gt;
&lt;p&gt;iOS中把release完但却没有完全消失的对象叫做僵尸对象，这时若再次释放，就会出现异常。苹果对此优化后的ARC对这种情况做了很多优化处理，但偶尔难免还是会出现。开启僵尸对象监听模式后，可以快速定位异常位置，便于我们快速调试。方法：Product–&amp;gt;Scheme–&amp;gt;Edit Scheme. 勾选Enable Zombie Objects即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/joshpell/G738nBWj/6MlYo.png =400x200&quot; alt=&quot;Thumper&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;五analyze分析器&quot;&gt;五、Analyze分析器&lt;/h3&gt;
&lt;p&gt;Analyze分析器是一种静态分析工具，可以对当前程序进行静态分析，找出未使用的变量或一些死储存等等。方法：Product–&amp;gt;Analyze.然后就是慢慢等它分析完，如下蓝色的标记就是静态分析的结果。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/joshpell/G73a9gTh/AuFpd.png =400x40&quot; alt=&quot;Thumper&quot; /&gt;
&lt;img src=&quot;http://pic.yupoo.com/joshpell/G73a9kFw/MHxeo.png =200x200&quot; alt=&quot;Thumper&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;六断点&quot;&gt;六、断点&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;普通断点&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;断点(Breakpoint)绝对是调试程序的第一大选择，也是有一个基础调试技能。断点打在哪儿当程序运行至此时就会暂停到这里（这一行未被执行）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/joshpell/G73fEqOg/AMPEV.png&quot; alt=&quot;Thumper&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击数字行数就在此行添加断点，再点击一次则取消（还有颜色，但不起断点作用了，可能是提醒你曾经在这里打过断点），调试中还能在下方调试信息区看到参数的值：
&lt;img src=&quot;http://pic.yupoo.com/joshpell/G73hnyMy/hCXKr.png =400x200&quot; alt=&quot;Thumper&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;条件断点&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面是最普通的断点使用方法，我们还能对断点的属性进行配置，设置条件，让断点更智能化&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/joshpell/G73l8Wdq/FkRh.png =200x100&quot; alt=&quot;Thumper&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击Edit Breadpoint…就是进入条件断点,以下面代码为例&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-(void)test{
	for (int i = 0;i &amp;lt; 5; i++){
		NSLog(@&quot;我的值：%d&quot;,i);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我并不想每次循环都有断点，只有在为3时需要，则条件如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/joshpell/G73kIPyS/RcVHi.png =400x300&quot; alt=&quot;Thumper&quot; /&gt;
&lt;img src=&quot;http://pic.yupoo.com/joshpell/G73kILIY/yVUta.png =400x300&quot; alt=&quot;Thumper&quot; /&gt;&lt;/p&gt;

&lt;p&gt;也可以查看某个方法被调用的次数，设置Action参数如下，注：要选中Automatically continue after evaluating actions。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/joshpell/G73kIHrl/3If2z.png =400x200&quot; alt=&quot;Thumper&quot; /&gt;&lt;/p&gt;

&lt;p&gt;控制台输入如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/joshpell/G73kIC82/FWnAt.png =400x200&quot; alt=&quot;Thumper&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;七异常断点&quot;&gt;七、异常断点&lt;/h3&gt;
&lt;p&gt;断点功能不止于上面所述，iOS开发者都遇到过，我们程序因为异常而crash代码就直接跑到main函数了。很多时候开发者不知道从何下手，下面就是讲用异常断点来让代码终止在出现异常的那一行
添加异常断点：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/joshpell/G73rC3cb/WnJa4.png =100x50&quot; alt=&quot;Thumper&quot; /&gt;&lt;/p&gt;

&lt;p&gt;若有异常则会出现下面图样的情况，点击进行查看：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/joshpell/G73rC03E/smK06.png =200x100&quot; alt=&quot;Thumper&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;符号断点 Symbolic Breakpoint&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;创建方法跟异常断点一样，符号断点可以在指定的类名或者方法名中执行异常中断
&lt;img src=&quot;http://pic.yupoo.com/joshpell/G73rBXiT/CqOeh.png =100x50&quot; alt=&quot;Thumper&quot; /&gt;
配置符号断点如下：假如需要在执行到ViewController类的viewDidLoad方法时执行中断。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/joshpell/G73rBTzl/KRJSx.png =400x200&quot; alt=&quot;Thumper&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果你的Symbol只写了一个函数名，那么就会在出现该函数名的地方就中断执行。如下，就会在运行到doAnimation的时候中断&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/joshpell/G73rBP4N/3bgut.png =400x200&quot; alt=&quot;Thumper&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以上就是跟大家分享的调试经验啦！&lt;/p&gt;
</description>
        <pubDate>Fri, 30 Dec 2016 16:08:08 +0800</pubDate>
        <link>http://localhost:4000/study/2016/12/30/iOS%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E6%80%BB%E7%BB%93/</link>
        <guid isPermaLink="true">http://localhost:4000/study/2016/12/30/iOS%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E6%80%BB%E7%BB%93/</guid>
        
        <category>iOS</category>
        
        <category>调试</category>
        
        <category>iOS开发调试总结</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>RunTime方法交换</title>
        <description>&lt;p&gt;现在我有个这种需求：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[UIImage imageNamed:@&quot;img1&quot;];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这个方法在图片不存在是会引起崩溃，这里先提供两种简单点的方法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;继承&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (UIImage *)imageNamed:(NSString *)name {

    // 恢复系统做法
    UIImage *image = [super imageNamed:name];
    if ( image == nil ) {
        NSLog(@&quot;加载失败&quot;);
    }
    return image;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;就是创建一个UIImage的子类，用子类的&lt;code class=&quot;highlighter-rouge&quot;&gt;imageNamed:&lt;/code&gt;方法加载图片&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;分类&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;分类方法挺好，简洁。切记，方法名不能重复系统方法名，可以加个前缀&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (UIImage *)TJ_imageNamed:(NSString *)name {

    // 恢复系统做法
    UIImage *image = [UIImage imageNamed:name];
    if ( image == nil ) {
        NSLog(@&quot;加载失败&quot;);
    }
    return image;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;大家看到这儿发现与我们的runtime还没半毛钱关系，稍安勿躁。现在需求变这样：一个项目，已经开发迭代两年，以前都是用UIImage加载图片，但现在项目老大要我们dui这个空图片的崩溃问题进行处理，一看看上面两个方法，懵逼中。。。。。。工程量太大，灯灯灯等！runtime登场：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;流程&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;提供分类&lt;/li&gt;
  &lt;li&gt;写一个有这样功能的方法&lt;/li&gt;
  &lt;li&gt;用这个方法跟系统方法进行方法交换&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;分类中的新方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (void)load {

    // 获取类方法
    // class:获取哪个类的方法
    // SEL:获取哪
    Method imageNameMethod = class_getClassMethod(self, @selector(imageNamed:));
    Method bj_imageNameMethod = class_getClassMethod(self, @selector(TJ_imageNamed:));

    // 交换方法的实现
    method_exchangeImplementations(imageNameMethod, bj_imageNameMethod);
}

+ (UIImage *)bj_imageNamed:(NSString *)name {

    UIImage *image = [UIImage bj_imageNamed:name];

    if (image == nil) {
        NSLog(@&quot;加载失败！\n&quot;);
    }

    return image;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;主线程直接调用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[UIImage imageNamed:@&quot;img1&quot;];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;方法交换示意图：
&lt;img src=&quot;http://pic.yupoo.com/joshpell/G5XK4VgE/rDp9G.png&quot; alt=&quot;Thumper&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 12 Dec 2016 16:08:08 +0800</pubDate>
        <link>http://localhost:4000/study/2016/12/12/RunTime%E6%96%B9%E6%B3%95%E4%BA%A4%E6%8D%A2/</link>
        <guid isPermaLink="true">http://localhost:4000/study/2016/12/12/RunTime%E6%96%B9%E6%B3%95%E4%BA%A4%E6%8D%A2/</guid>
        
        <category>runtime</category>
        
        <category>方法交换</category>
        
        <category>RunTime方法交换</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>RunTime动态添加方法和属性</title>
        <description>&lt;h3 id=&quot;动态添加方法&quot;&gt;动态添加方法&lt;/h3&gt;

&lt;p&gt;面试的时候面试官可能会问用过performSelector方法么，那就请注意了，他百分之百问的是跟runtime有关的知识，不要傻乎乎的以为他就是问你有没有用过这个方法了，然后你还跟他扯可以延迟调用方法啥的，这些都是OC封装好的，相信我他不是在考你这个。&lt;/p&gt;

&lt;p&gt;performSelector方法区别于直接调用，直接调用时假如你方法没实现，编译直接报错，而performSelector只会报警告，所以人家是问你runtime动态添加方法的东西。&lt;/p&gt;

&lt;p&gt;动态添加方法是一个很有意义的事情，因为程序在编译的时候，会把所有的方法加到一个方法列表中，但是我们并不是所有的方法都会使用到，耗时耗力。我们应该多利用懒加载的方式，用到某个方法，再添加，不用的方法就不用管它。&lt;/p&gt;

&lt;p&gt;首先我们需要导入#import &amp;lt;objc/message.h&amp;gt;，然后写下下面2个方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 当某个类方法只声明，没有实现的时候，会执行下面的方法
+ (BOOL)resolveClassMethod:(SEL)sel;
// 当某个对象方法没有只声明，没有实现的时候，会执行下面的方法。
+ (BOOL)resolveInstanceMethod:(SEL)sel ;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们先创建一个函数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void eat(id self, SEL _cmd,id param1){
    NSLog(@&quot;调用%@---%@---%@&quot;,self,NSStringFromSelector(_cmd),param1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;讲解一下，每一个函数，都有2个默认的隐式参数，一个是谁调用了自己，一个是SEL，SEL就是对方法的一种包装。包装的SEL类型数据它对应相应的方法地址,找到方法地址就可以调用方法。后面的id类型的param1是我写的一个参数，因为是C语言的函数，我们无法创建NS之类的类型，这里我就用id类型来接参数。&lt;/p&gt;

&lt;p&gt;接下来，根据官方文档我们可以添加下面的代码做判断，使得在找不到eat方法的时候，可以执行我们动态添加的eat方法，注意，上面的函数名可以随意写，只需要在下面添加方法的时候做好关联就好：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 外界调用一个没有实现的对象方法-
// resolveInstanceMethod中sel是没有实现的参数
+ (BOOL)resolveInstanceMethod:(SEL)sel{

    NSLog(@&quot;%@&quot;,NSStringFromSelector(sel));
//    if (sel == @selector(eat)) {}这句话等同下面的判断

    if ([NSStringFromSelector(sel) isEqualToString:@&quot;eat:&quot;] ) {
        // 这里添加方法
        // 给哪个类
        //SEL:方法名
        //IMP:方法的实现（函数的入口-函数的指针-函数的名）
        //type :方法类型
        class_addMethod(self, sel, (IMP)eat, &quot;v@:@&quot;); 
        returnYES;
    }
    return [super resolveInstanceMethod:sel];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里介绍一下OBJC_EXPORT BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)这个函数的参数意义&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Class cls:就是你给哪个类添加的这个方法
SEL name：就是方法名字是啥，默认进入方法的时候，肯定是方法上带的参数sel没有，所以我们这里传入的是sel。
(IMP)eat：这里需要我们传入一个IMP，啥实IMP,IMP就是方法的实现（函数的入口-函数的指针-函数的名）大家这里意会下
 const char *types，这里我们可以好好说一说。我先说下意思，*v@:@*的意思就是，返回类型是void,参数是id,SEL,id。具体大家参考上面我写的函数以及函数说明。

如果想查到这些代表啥意思，可以打开苹果文档，输入Type Encodings，选择我箭头所指。查询。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/joshpell/G5YKO1rz/BI7j7.png&quot; alt=&quot;Thumper&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;动态添加属性&quot;&gt;动态添加属性&lt;/h3&gt;
&lt;p&gt;通过运行时添加属性，使用面还是比较广的。比如想给button类绑定一个属性，大家肯定会继承button来操作。其实通过运行时添加属性，我们就可以实现给系统button添加一个属性的需求。&lt;/p&gt;

&lt;p&gt;默认我们在创建分类的时候，添加一个成员属性后，大家往往会发现，直接调用这个类的点语法，我们获取不了属性,为什么呢？&lt;/p&gt;

&lt;p&gt;因为默认分类创建的属性，不会执行set和get方法。如果我们一定要获取到这个属性，我们应该怎么做呢？这里有2种方法，一种就是添加一个静态变量，重写它的set和get方法.另外一种就是通过运行时，添加这个属性。这里我只讲第二种，代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 声明一个char型的key
static char nameKey;

- (void)setName:(NSString *)name
{
    // 属性跟对象有关联-就是添加属性

    // object:对象
    // key:属性名，根据key去获取到值
    // value:值
    // policy：策略
    objc_setAssociatedObject(self, &amp;amp;nameKey, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里我讲一下OBJC_EXPORT void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)这个方法。&lt;/p&gt;

&lt;p&gt;这个方法的字面意思就是把一个值，通过一个key绑定到一个类中，最后设置一下保存的策略。代码的意思是，把name的值，通过nameKey绑定到当前类，保存的是nonatomic的copy类型。
补充一下最后一个参数（策略）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// assign类型
   OBJC_ASSOCIATION_ASSIGN = 0,
// 非原子性Retain--&amp;gt;相当于Strong
    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1,
// 非原子性 copy-
    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,
// 原子性Retain
    OBJC_ASSOCIATION_RETAIN = 01401,
// 原子性copy
    OBJC_ASSOCIATION_COPY
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;取得动态绑定属性的方法如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (NSString *)name
{
    return objc_getAssociatedObject(self, &amp;amp;nameKey);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;简单的解释就是通过self这个类的，nameKey这个key,我们就可以取到nameKey相对应的值了。这就是如何通过runtime来动态的给类添加属性了，帅哥，你可以试试了！&lt;/p&gt;

</description>
        <pubDate>Mon, 12 Dec 2016 16:08:08 +0800</pubDate>
        <link>http://localhost:4000/study/2016/12/12/RunTime%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7/</link>
        <guid isPermaLink="true">http://localhost:4000/study/2016/12/12/RunTime%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7/</guid>
        
        <category>runtime</category>
        
        <category>动态添加</category>
        
        <category>RunTime动态添加方法和属性</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>xib作为cell时的复用问题</title>
        <description>&lt;p&gt;apple鼓励大家使用图形化界面开发，这样效率更高，但我们在使用xib新建cell的时候会遇到问题,xib新建时是没有&lt;code class=&quot;highlighter-rouge&quot;&gt;initWithStyle: reuseIdentifier:&lt;/code&gt;这个方法的，但为了效率cell还是需要复用，所以就需要用下面方法来新建cell了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    MyCustomCell * cell = [tableView dequeueReusableCellWithIdentifier:@&quot;myCell&quot;];
    if (!cell){
    
        [tableView registerNib:[UINib nibWithNibName:@&quot;MyCustomCell&quot; bundle:nil] forCellReuseIdentifier:@&quot;myCell&quot;];
        cell = [tableView dequeueReusableCellWithIdentifier:@&quot;myCell&quot;];
    }
    return cell;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Mon, 12 Dec 2016 16:08:08 +0800</pubDate>
        <link>http://localhost:4000/tips/2016/12/12/xib%E4%BD%9C%E4%B8%BAcell%E6%97%B6%E7%9A%84%E5%A4%8D%E7%94%A8%E9%97%AE%E9%A2%98/</link>
        <guid isPermaLink="true">http://localhost:4000/tips/2016/12/12/xib%E4%BD%9C%E4%B8%BAcell%E6%97%B6%E7%9A%84%E5%A4%8D%E7%94%A8%E9%97%AE%E9%A2%98/</guid>
        
        <category>xib</category>
        
        <category>复用</category>
        
        <category>xib作为cell时的复用问题</category>
        
        
        <category>tips</category>
        
      </item>
    
      <item>
        <title>WKWebKit介绍</title>
        <description>&lt;p&gt;苹果在iOS8推出了一个新的框架&lt;code class=&quot;highlighter-rouge&quot;&gt;WKWebKit&lt;/code&gt;，更好地内存优化、更快的加载速度和更丰富的接口让它成为了开发者手中的香馍馍，替代UIWebView就变得顺理成章。&lt;/p&gt;

&lt;p&gt;UIWebView&amp;amp;UIWebDelegate这两个东西在WKWebKit中被重构成16个类、3个协议&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Classes&lt;/em&gt;&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;WKBackForwardList：历史记录列表，可以通过后退和前进动作访问到；（- itemAtIndex: 该类中唯一方法，用于返回项目在指定的距离当前项目。还有backItem、currentItem、forwardItem、backList、forwardList属性）&lt;/li&gt;
  &lt;li&gt;WKBackForwardListItem：webView中后退列表里的某一网页；（有URL、title、initialURL三个属性）&lt;/li&gt;
  &lt;li&gt;WKFrameInfo:包含一个框架在一个网页的信息；（有mainFrame、request、securityOrigin三个属性，其中securityOrigin是一个WKSecurityOrigin对象属性，iOS9之后可使用，是由一个主机名称，协议和端口号组成。）&lt;/li&gt;
  &lt;li&gt;WKNavigation：包含一个网页加载进度信息；&lt;/li&gt;
  &lt;li&gt;WKNavigationAction：包含可能让网页导航变化的信息，用于判断是否做出导航变化；（值得注意的是可能会常用的 WKNavigationType这个枚举）&lt;/li&gt;
  &lt;li&gt;WKNavigationResponse：包含可能让网页导航变化的返回内容信息，用于判断是否做出导航变化；&lt;/li&gt;
  &lt;li&gt;WKPreferences：概括一个webView的偏好设置；（ minimumFontSize、 javaScriptEnabled、 javaScriptCanOpenWindowsAutomatically三个属性，值得注意的是后两个属性，一个决定是否启用javaScript,另一个是在没有用户交互的情况下，是否JavaScript可以打开windows）&lt;/li&gt;
  &lt;li&gt;WKProcessPool：表示一个web内容加载池；&lt;/li&gt;
  &lt;li&gt;WKUserContentController：提供使用JavaScript post信息和注射script的方法。（- addScriptMessageHandler:name: 添加一个消息处理程序脚本 - addUserScript: 添加一个用户脚本 - removeAllUserScripts remove所有用户脚本 —removeScriptMessageHandlerForName: 删除一个消息处理程序的脚本 和一个userScript属性： 与用户相关联的用户脚本内容控制器）&lt;/li&gt;
  &lt;li&gt;WKScriptMessage: 包含网页发出的信息。（body、webView、frameInfo、name）&lt;/li&gt;
  &lt;li&gt;WKUserScript：表示可以被网页接受的用户脚本。&lt;/li&gt;
  &lt;li&gt;WKWebViewConfiguration: 初始化 webview 的设置。（- initWithSource:injectionTime:forMainFrameOnly: 返回一个初始化用户脚本,可以添加到一个用户内容控制器 还有source、injectionTime、forMainFrameOnly）&lt;/li&gt;
  &lt;li&gt;WKWindowFeatures:指定加载新网页时的窗口属性。(全是窗口属性)&lt;/li&gt;
  &lt;li&gt;WKWebViewConfiguration:对象是属性的集合用来初始化一个web视图。(属性比较多，不过这个对象在初始化web视图的时候必须会用到)&lt;/li&gt;
  &lt;li&gt;还有WKWebsiteDataStore&amp;amp;WKWebsiteDataRecord两个类&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Protocols&lt;/em&gt;&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;WKNavigationDelegate:提供了追踪主窗口网页加载过程和判断主窗口和子窗口是否进行页面加载新页面的相关方法。&lt;/li&gt;
  &lt;li&gt;WKScriptMessageHandler: 提供从网页中收消息的回调方法。&lt;/li&gt;
  &lt;li&gt;WKUIDelegate: 提供用原生控件显示网页的方法回调。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;WKNavigationDelegate&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;webView:didCommitNavigation: 主框架在内容开始到达时调用。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;webView:didFailNavigation:withError: 主框架导航发生错误时调用。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;webView:didFailProvisionalNavigation:withError: 主框架在开始加载数据出现错误时调用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;webView:didFinishNavigation: 主框架导航完成时调用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;webView:didReceiveAuthenticationChallenge:completionHandler: web视图需要响应身份验证时调用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;webView:didReceiveServerRedirectForProvisionalNavigation: 主服务器接受到重定向时调用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;webView:didStartProvisionalNavigation: 主框架导航开始时调用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;webView:decidePolicyForNavigationAction:decisionHandler: 决定是否允许或取消一个导航&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;webView:decidePolicyForNavigationResponse:decisionHandler: 决定是否允许或取消一个导航后其反应是已知的&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;WKScriptMessageHandler&lt;/em&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;userContentController:didReceiveScriptMessage:（required）一个脚本从一个网页接收到消息时调用&lt;/li&gt;
  &lt;li&gt;WKUIDelegate：&lt;/li&gt;
  &lt;li&gt;webView:createWebViewWithConfiguration:forNavigationAction:windowFeatures:创建一个新的webView&lt;/li&gt;
  &lt;li&gt;webView:runJavaScriptAlertPanelWithMessage:initiatedByFrame:completionHandler: 显示一个JavaScript警告面板。&lt;/li&gt;
  &lt;li&gt;webView:runJavaScriptConfirmPanelWithMessage:initiatedByFrame:completionHandler:显示一个JavaScript确认面板。&lt;/li&gt;
  &lt;li&gt;webView:runJavaScriptTextInputPanelWithPrompt:defaultText:initiatedByFrame:completionHandler: 显示一个JavaScript文本输入面板。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中一些类中的枚举状态：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef NS_ENUM(NSInteger, WKNavigationType) {
    WKNavigationTypeLinkActivated,//链接的href属性被用户激活。
    WKNavigationTypeFormSubmitted,//一个表单提交。
    WKNavigationTypeBackForward,//回到前面的条目列表请求。
    WKNavigationTypeReload,//网页加载。
    WKNavigationTypeFormResubmitted,//一个表单提交(例如通过前进,后退,或重新加载)。
    WKNavigationTypeOther = -1,//导航是发生一些其他原因。
} NS_ENUM_AVAILABLE(10_10, 8_0);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef NS_ENUM(NSInteger, WKUserScriptInjectionTime) {
    WKUserScriptInjectionTimeAtDocumentStart,//注入后的脚本创建文档元素,但在其他任何内容已经被加载。
    WKUserScriptInjectionTimeAtDocumentEnd//注入脚本文档完成加载后,但在任何子资源可能完成加载。
}
NS_ENUM_AVAILABLE(10_10, 8_0);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef NS_ENUM(NSInteger, WKNavigationActionPolicy) {
    WKNavigationActionPolicyCancel,//取消导航
    WKNavigationActionPolicyAllow,//允许导航继续
} NS_ENUM_AVAILABLE(10_10, 8_0);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef NS_ENUM(NSInteger, WKNavigationResponsePolicy) {
    WKNavigationResponsePolicyCancel,//取消导航
    WKNavigationResponsePolicyAllow,//允许导航继续
} NS_ENUM_AVAILABLE(10_10, 8_0);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Mon, 12 Dec 2016 16:08:08 +0800</pubDate>
        <link>http://localhost:4000/study/2016/12/12/WKWebKit%E4%BB%8B%E7%BB%8D/</link>
        <guid isPermaLink="true">http://localhost:4000/study/2016/12/12/WKWebKit%E4%BB%8B%E7%BB%8D/</guid>
        
        <category>WKWebKit</category>
        
        <category>WKWebKit介绍</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>emoji表情作为单字符长度的处理</title>
        <description>&lt;p&gt;我们知道emoji表情是一些特殊格式的字符串，因此我们在计算其长度的时候直接用“xxx.length”即可，但有时候产品经理会要求你把所有的emoji表情都当做一个字符处理，别问我怎么知道的😭😭😭，这里写下来希望大家不要跟我一样到处跳坑&lt;/p&gt;

&lt;p&gt;还是直接上代码&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;获取emoji个数（我这里写到了NSString的类方法中）&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
+ (NSInteger)emojiCountInString:(NSString *)string
{
    __block NSInteger num = 0;
    [string enumerateSubstringsInRange:NSMakeRange(0, [string length])
                               options:NSStringEnumerationByComposedCharacterSequences
                            usingBlock:^(NSString * _Nullable substring, NSRange substringRange, NSRange enclosingRange, BOOL * _Nonnull stop) {
		const unichar hs = [substring characterAtIndex:0];
		if (0xd800 &amp;lt;= hs &amp;amp;&amp;amp; hs &amp;lt;= 0xdbff){
			if (substring.length &amp;gt; 1) {
				const unichar ls = [substring characterAtIndex:1];
			    const int uc = ((hs - 0xd800) * 0x400) + (ls - 0xdc00) + 0x10000;
				if (0x1d000 &amp;lt;= uc &amp;amp;&amp;amp; uc &amp;lt;= 0x1f918)
				{
					num += 1;
				}
			}
		}
		else if (substring.length &amp;gt; 1)
		{
			const unichar ls = [substring characterAtIndex:1];
			if (ls == 0x20e3 || ls == 0xFE0F || ls == 0xd83c)
			{
				num += 1;
			}
		}
	    else{
		// non surrogate
			if (0x2100 &amp;lt;= hs &amp;amp;&amp;amp; hs &amp;lt;= 0x27ff)
			{
			if (0x278b &amp;lt;= hs &amp;amp;&amp;amp; 0x2792 &amp;gt;= hs)
			{
				//不为emoji
			}
			else
			{
				num += 1;
			}
		}
		else if (0x2B05 &amp;lt;= hs &amp;amp;&amp;amp; hs &amp;lt;= 0x2b07)
		{
			num += 1;
		}
		else if (0x2934 &amp;lt;= hs &amp;amp;&amp;amp; hs &amp;lt;= 0x2935)
		{
			num += 1;
		}
		else if (0x3297 &amp;lt;= hs &amp;amp;&amp;amp; hs &amp;lt;= 0x3299)
		{
			num += 1;
		}
		else if (hs == 0xa9 || hs == 0xae || hs == 0x303d || hs == 0x3030 || hs == 0x2b55 || hs == 0x2b1c || hs == 0x2b1b || hs == 0x2b50 || hs == 0xd83e)
		{
			num += 1;
		}
	}
	}];
    return num;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;字符串去掉emoji&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
+ (NSString *)getStringWithoutEmoji:(NSString *)string
{
    __block NSString *tempStr = string;
    [string enumerateSubstringsInRange:NSMakeRange(0, [string length])
                               options:NSStringEnumerationByComposedCharacterSequences
                            usingBlock:^(NSString * _Nullable substring, NSRange substringRange, NSRange enclosingRange, BOOL * _Nonnull stop) {
                                const unichar hs = [substring characterAtIndex:0];
                                // surrogate pair
                                if (0xd800 &amp;lt;= hs &amp;amp;&amp;amp; hs &amp;lt;= 0xdbff)
                                {
                                    if (substring.length &amp;gt; 1)
                                    {
                                        const unichar ls = [substring characterAtIndex:1];
                                        const int uc = ((hs - 0xd800) * 0x400) + (ls - 0xdc00) + 0x10000;
                                        if (0x1d000 &amp;lt;= uc &amp;amp;&amp;amp; uc &amp;lt;= 0x1f918)
                                        {

                                            tempStr = [tempStr stringByReplacingOccurrencesOfString:substring withString:@&quot;&quot;];
                                        }
                                    }
                                }
                                else if (substring.length &amp;gt; 1)
                                {
                                    const unichar ls = [substring characterAtIndex:1];
                                    if (ls == 0x20e3 || ls == 0xFE0F || ls == 0xd83c)
                                    {
                                        tempStr = [tempStr stringByReplacingOccurrencesOfString:substring withString:@&quot;&quot;];
                                    }
                                }
                                else
                                {
                                    // non surrogate
                                    if (0x2100 &amp;lt;= hs &amp;amp;&amp;amp; hs &amp;lt;= 0x27ff)
                                    {
                                        if (0x278b &amp;lt;= hs &amp;amp;&amp;amp; 0x2792 &amp;gt;= hs)
                                        {
                                            //不为emoji
                                        }
                                        else
                                        {
                                            tempStr = [tempStr stringByReplacingOccurrencesOfString:substring withString:@&quot;&quot;];
                                        }
                                    }
                                    else if (0x2B05 &amp;lt;= hs &amp;amp;&amp;amp; hs &amp;lt;= 0x2b07)
                                    {
                                        tempStr = [tempStr stringByReplacingOccurrencesOfString:substring withString:@&quot;&quot;];
                                    }
                                    else if (0x2934 &amp;lt;= hs &amp;amp;&amp;amp; hs &amp;lt;= 0x2935)
                                    {
                                        tempStr = [tempStr stringByReplacingOccurrencesOfString:substring withString:@&quot;&quot;];
                                    }
                                    else if (0x3297 &amp;lt;= hs &amp;amp;&amp;amp; hs &amp;lt;= 0x3299)
                                    {
                                        tempStr = [tempStr stringByReplacingOccurrencesOfString:substring withString:@&quot;&quot;];
                                    }
                                    else if (hs == 0xa9 || hs == 0xae || hs == 0x303d || hs == 0x3030 || hs == 0x2b55 || hs == 0x2b1c || hs == 0x2b1b || hs == 0x2b50 || hs == 0xd83e)
                                    {
                                        tempStr = [tempStr stringByReplacingOccurrencesOfString:substring withString:@&quot;&quot;];
                                    }
                                }
                            }];
    return tempStr;
}



&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;获取把emoji表情当成单个字符长度处理后的字符串长度&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-(NSInteger)lengthWithEmojiString{
    NSInteger emojiLen = [NSString emojiCountInString:self];
    NSString * normalStr = [NSString getStringWithoutEmoji:self];
    NSInteger strLengh = normalStr.length+emojiLen;
    return strLengh;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 08 Nov 2016 16:08:08 +0800</pubDate>
        <link>http://localhost:4000/study/2016/11/08/emoji%E8%A1%A8%E6%83%85%E4%BD%9C%E4%B8%BA%E5%8D%95%E5%AD%97%E7%AC%A6%E9%95%BF%E5%BA%A6%E7%9A%84%E5%A4%84%E7%90%86/</link>
        <guid isPermaLink="true">http://localhost:4000/study/2016/11/08/emoji%E8%A1%A8%E6%83%85%E4%BD%9C%E4%B8%BA%E5%8D%95%E5%AD%97%E7%AC%A6%E9%95%BF%E5%BA%A6%E7%9A%84%E5%A4%84%E7%90%86/</guid>
        
        <category>emoji</category>
        
        <category>长度</category>
        
        <category>emoji表情作为单字符长度的处理</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>block中weakSelf和strongSelf的简化</title>
        <description>&lt;p&gt;我们知道在block中使用全局变量需要考虑到循环引用问题，这时就会引入weakSelf和strongSelf，具体用法不多说，网上很多介绍的文章，比如&lt;a href=&quot;http://www.jianshu.com/p/701da54bd78c&quot;&gt;深入研究Block用weakSelf、strongSelf、@weakify、@strongify解决循环引用&lt;/a&gt;
  但是频繁的书写weakSelf和strongSelf会让人觉得代码重复，但是这个东西又不好抽取。经过多方打探，找到一个特别简便的方法，你不用再考虑weakSelf和strongSelf的书写，直接使用self代替即可。在文件中加入下面的宏即可。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define weakify(...) \
    ext_keywordify \
    metamacro_foreach_cxt(ext_weakify_,, __weak, __VA_ARGS__)
#define strongify(...) \
    ext_keywordify \
    _Pragma(&quot;clang diagnostic push&quot;) \
    _Pragma(&quot;clang diagnostic ignored \&quot;-Wshadow\&quot;&quot;) \
    metamacro_foreach(ext_strongify_,, __VA_ARGS__) \
    _Pragma(&quot;clang diagnostic pop&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 18 Oct 2016 16:08:08 +0800</pubDate>
        <link>http://localhost:4000/efficiency/2016/10/18/block%E4%B8%ADweakSelf%E5%92%8CstrongSelf%E7%9A%84%E7%AE%80%E5%8C%96/</link>
        <guid isPermaLink="true">http://localhost:4000/efficiency/2016/10/18/block%E4%B8%ADweakSelf%E5%92%8CstrongSelf%E7%9A%84%E7%AE%80%E5%8C%96/</guid>
        
        <category>循环引用</category>
        
        <category>block</category>
        
        <category>self</category>
        
        <category>block中weakSelf和strongSelf的简化</category>
        
        
        <category>Efficiency</category>
        
      </item>
    
  </channel>
</rss>
