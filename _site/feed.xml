<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Josh Pell'Page</title>
    <description>When you think you can stop learning, is a time when you are going to be washed out.</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 30 Dec 2016 16:31:20 +0800</pubDate>
    <lastBuildDate>Fri, 30 Dec 2016 16:31:20 +0800</lastBuildDate>
    <generator>Jekyll v3.3.1</generator>
    
      <item>
        <title>iOS开发调试总结</title>
        <description>&lt;p&gt;软件开发工作，调试是必备技能，重要性不多说。而调试方法在不同的平台和语言中大部分都是可以互相迁移借鉴的。不同语言、不同IDE、不同平台的调试，有同性也有个性。本人iOS 10开发，语言就用OC，IDE就用Xcode，来唠唠开发调试&lt;/p&gt;

&lt;p&gt;###一、NSLog打印
NSLog打印是最常用的调试方法，也是初学者最喜欢最简单的调试方法，通过打印信息来查看运行路径和数据等。但打印出的信息比较少，NSLog本身效率也较低，但也不失为一种方法。用下面的宏做NSLog的优化，可以打印类名、所在方法名、详细时间和行号等信息。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define JFLog(format, ...) do { \
    fprintf(stderr,&quot;&amp;lt;%s : %d&amp;gt; %s\n&quot;, \
    [[[NSString stringWithUTF8String:__FILE__] lastPathComponent] UTF8String], \
    __LINE__, __func__); \
    (NSLog)((format), ##__VA_ARGS__); \
    fprintf(stderr,&quot;-------\n&quot;); \
} while (0)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;###二、生命周期方法init、dealloc
在ViewController中，有两个生命周期方法我们可以重写，也就是init、dealloc方法。对于监听某些对象的状态很有帮助，特别是在dealloc方法中查看当ViewController退出的时候某个对象有没有release掉。这里也没有啥代码，自己视情况而定。&lt;/p&gt;

&lt;p&gt;###三、查看代码运行时间
有时候需要做代码优化或者耗时操作，分析效率问题，就需要知道代码的执行时间长短。网上看了看资料，直接使用宏就行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define CODE_START NSDate *startTime = [NSDate date]
#define CODE_END   NSLog(@&quot;Time:%f&quot;,-[startTime timeIntervalSinceNow])
//用法
	CODE_START;
   //放置被监测代码
   CODE_END;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;控制台打印：
&lt;img src=&quot;http://pic.yupoo.com/joshpell/G72XQEDV/GRPz7.png&quot; alt=&quot;Thumper&quot; /&gt;&lt;/p&gt;

&lt;p&gt;###四、僵尸对象
iOS中把release完但却没有完全消失的对象叫做僵尸对象，这时若再次释放，就会出现异常。苹果对此优化后的ARC对这种情况做了很多优化处理，但偶尔难免还是会出现。开启僵尸对象监听模式后，可以快速定位异常位置，便于我们快速调试。方法：Product–&amp;gt;Scheme–&amp;gt;Edit Scheme. 勾选Enable Zombie Objects即可。
&lt;img src=&quot;http://pic.yupoo.com/joshpell/G738nBWj/6MlYo.png&quot; alt=&quot;Thumper&quot; /&gt;&lt;/p&gt;

&lt;p&gt;###五、Analyze分析器
Analyze分析器是一种静态分析工具，可以对当前程序进行静态分析，找出未使用的变量或一些死储存等等。方法：Product–&amp;gt;Analyze.然后就是慢慢等它分析完，如下蓝色的标记就是静态分析的结果。
&lt;img src=&quot;http://pic.yupoo.com/joshpell/G73a9gTh/AuFpd.png&quot; alt=&quot;Thumper&quot; /&gt;
&lt;img src=&quot;http://pic.yupoo.com/joshpell/G73a9kFw/MHxeo.png&quot; alt=&quot;Thumper&quot; /&gt;&lt;/p&gt;

&lt;p&gt;###六、断点&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;普通断点&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;断点(Breakpoint)绝对是调试程序的第一大选择，也是有一个基础调试技能。断点打在哪儿当程序运行至此时就会暂停到这里（这一行未被执行）。
&lt;img src=&quot;http://pic.yupoo.com/joshpell/G73fEqOg/AMPEV.png&quot; alt=&quot;Thumper&quot; /&gt;
点击数字行数就在此行添加断点，再点击一次则取消（还有颜色，但不起断点作用了，可能是提醒你曾经在这里打过断点），调试中还能在下方调试信息区看到参数的值：
&lt;img src=&quot;http://pic.yupoo.com/joshpell/G73hnyMy/hCXKr.png&quot; alt=&quot;Thumper&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;条件断点&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面是最普通的断点使用方法，我们还能对断点的属性进行配置，设置条件，让断点更智能化
&lt;img src=&quot;http://pic.yupoo.com/joshpell/G73l8Wdq/FkRh.png&quot; alt=&quot;Thumper&quot; /&gt;
点击Edit Breadpoint…就是进入条件断点,以下面代码为例&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-(void)test{
	for (int i = 0;i &amp;lt; 5; i++){
		NSLog(@&quot;我的值：%d&quot;,i);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我并不想每次循环都有断点，只有在为3时需要，则条件如下：
&lt;img src=&quot;http://pic.yupoo.com/joshpell/G73kIPyS/RcVHi.png&quot; alt=&quot;Thumper&quot; /&gt;
&lt;img src=&quot;http://pic.yupoo.com/joshpell/G73kILIY/yVUta.png&quot; alt=&quot;Thumper&quot; /&gt;
也可以查看某个方法被调用的次数，设置Action参数如下，注：要选中Automatically continue after evaluating actions。
&lt;img src=&quot;http://pic.yupoo.com/joshpell/G73kIHrl/3If2z.png&quot; alt=&quot;Thumper&quot; /&gt;
控制台输入如下：
&lt;img src=&quot;http://pic.yupoo.com/joshpell/G73kIC82/FWnAt.png&quot; alt=&quot;Thumper&quot; /&gt;&lt;/p&gt;

&lt;p&gt;###七、异常断点
断点功能不止于上面所述，iOS开发者都遇到过，我们程序因为异常而crash代码就直接跑到main函数了。很多时候开发者不知道从何下手，下面就是讲用异常断点来让代码终止在出现异常的那一行
添加异常断点：
&lt;img src=&quot;http://pic.yupoo.com/joshpell/G73rC3cb/WnJa4.png&quot; alt=&quot;Thumper&quot; /&gt;
若有异常则会出现下面图样的情况，点击进行查看：
&lt;img src=&quot;http://pic.yupoo.com/joshpell/G73rC03E/smK06.png&quot; alt=&quot;Thumper&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;符号断点 Symbolic Breakpoint&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;创建方法跟异常断点一样，符号断点可以在指定的类名或者方法名中执行异常中断
&lt;img src=&quot;http://pic.yupoo.com/joshpell/G73rBXiT/CqOeh.png&quot; alt=&quot;Thumper&quot; /&gt;
配置符号断点如下：假如需要在执行到ViewController类的viewDidLoad方法时执行中断。
&lt;img src=&quot;http://pic.yupoo.com/joshpell/G73rBTzl/KRJSx.png&quot; alt=&quot;Thumper&quot; /&gt;
如果你的Symbol只写了一个函数名，那么就会在出现该函数名的地方就中断执行。如下，就会在运行到doAnimation的时候中断
&lt;img src=&quot;http://pic.yupoo.com/joshpell/G73rBP4N/3bgut.png&quot; alt=&quot;Thumper&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以上就是跟大家分享的调试经验啦！&lt;/p&gt;
</description>
        <pubDate>Fri, 30 Dec 2016 16:08:08 +0800</pubDate>
        <link>http://localhost:4000/study/2016/12/30/iOS%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E6%80%BB%E7%BB%93/</link>
        <guid isPermaLink="true">http://localhost:4000/study/2016/12/30/iOS%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E6%80%BB%E7%BB%93/</guid>
        
        <category>iOS</category>
        
        <category>调试</category>
        
        <category>iOS开发调试总结</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>RunTime方法交换</title>
        <description>&lt;p&gt;现在我有个这种需求：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[UIImage imageNamed:@&quot;img1&quot;];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这个方法在图片不存在是会引起崩溃，这里先提供两种简单点的方法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;继承&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (UIImage *)imageNamed:(NSString *)name {

    // 恢复系统做法
    UIImage *image = [super imageNamed:name];
    if ( image == nil ) {
        NSLog(@&quot;加载失败&quot;);
    }
    return image;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;就是创建一个UIImage的子类，用子类的&lt;code class=&quot;highlighter-rouge&quot;&gt;imageNamed:&lt;/code&gt;方法加载图片&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;分类&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;分类方法挺好，简洁。切记，方法名不能重复系统方法名，可以加个前缀&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (UIImage *)TJ_imageNamed:(NSString *)name {

    // 恢复系统做法
    UIImage *image = [UIImage imageNamed:name];
    if ( image == nil ) {
        NSLog(@&quot;加载失败&quot;);
    }
    return image;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;大家看到这儿发现与我们的runtime还没半毛钱关系，稍安勿躁。现在需求变这样：一个项目，已经开发迭代两年，以前都是用UIImage加载图片，但现在项目老大要我们dui这个空图片的崩溃问题进行处理，一看看上面两个方法，懵逼中。。。。。。工程量太大，灯灯灯等！runtime登场：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;流程&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;提供分类&lt;/li&gt;
  &lt;li&gt;写一个有这样功能的方法&lt;/li&gt;
  &lt;li&gt;用这个方法跟系统方法进行方法交换&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;分类中的新方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (void)load {

    // 获取类方法
    // class:获取哪个类的方法
    // SEL:获取哪
    Method imageNameMethod = class_getClassMethod(self, @selector(imageNamed:));
    Method bj_imageNameMethod = class_getClassMethod(self, @selector(TJ_imageNamed:));

    // 交换方法的实现
    method_exchangeImplementations(imageNameMethod, bj_imageNameMethod);
}

+ (UIImage *)bj_imageNamed:(NSString *)name {

    UIImage *image = [UIImage bj_imageNamed:name];

    if (image == nil) {
        NSLog(@&quot;加载失败！\n&quot;);
    }

    return image;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;主线程直接调用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[UIImage imageNamed:@&quot;img1&quot;];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;方法交换示意图：
&lt;img src=&quot;http://pic.yupoo.com/joshpell/G5XK4VgE/rDp9G.png&quot; alt=&quot;Thumper&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 12 Dec 2016 16:08:08 +0800</pubDate>
        <link>http://localhost:4000/study/2016/12/12/RunTime%E6%96%B9%E6%B3%95%E4%BA%A4%E6%8D%A2/</link>
        <guid isPermaLink="true">http://localhost:4000/study/2016/12/12/RunTime%E6%96%B9%E6%B3%95%E4%BA%A4%E6%8D%A2/</guid>
        
        <category>runtime</category>
        
        <category>方法交换</category>
        
        <category>RunTime方法交换</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>RunTime动态添加方法和属性</title>
        <description>&lt;h3 id=&quot;动态添加方法&quot;&gt;动态添加方法&lt;/h3&gt;

&lt;p&gt;面试的时候面试官可能会问用过performSelector方法么，那就请注意了，他百分之百问的是跟runtime有关的知识，不要傻乎乎的以为他就是问你有没有用过这个方法了，然后你还跟他扯可以延迟调用方法啥的，这些都是OC封装好的，相信我他不是在考你这个。&lt;/p&gt;

&lt;p&gt;performSelector方法区别于直接调用，直接调用时假如你方法没实现，编译直接报错，而performSelector只会报警告，所以人家是问你runtime动态添加方法的东西。&lt;/p&gt;

&lt;p&gt;动态添加方法是一个很有意义的事情，因为程序在编译的时候，会把所有的方法加到一个方法列表中，但是我们并不是所有的方法都会使用到，耗时耗力。我们应该多利用懒加载的方式，用到某个方法，再添加，不用的方法就不用管它。&lt;/p&gt;

&lt;p&gt;首先我们需要导入#import &amp;lt;objc/message.h&amp;gt;，然后写下下面2个方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 当某个类方法只声明，没有实现的时候，会执行下面的方法
+ (BOOL)resolveClassMethod:(SEL)sel;
// 当某个对象方法没有只声明，没有实现的时候，会执行下面的方法。
+ (BOOL)resolveInstanceMethod:(SEL)sel ;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们先创建一个函数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void eat(id self, SEL _cmd,id param1){
    NSLog(@&quot;调用%@---%@---%@&quot;,self,NSStringFromSelector(_cmd),param1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;讲解一下，每一个函数，都有2个默认的隐式参数，一个是谁调用了自己，一个是SEL，SEL就是对方法的一种包装。包装的SEL类型数据它对应相应的方法地址,找到方法地址就可以调用方法。后面的id类型的param1是我写的一个参数，因为是C语言的函数，我们无法创建NS之类的类型，这里我就用id类型来接参数。&lt;/p&gt;

&lt;p&gt;接下来，根据官方文档我们可以添加下面的代码做判断，使得在找不到eat方法的时候，可以执行我们动态添加的eat方法，注意，上面的函数名可以随意写，只需要在下面添加方法的时候做好关联就好：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 外界调用一个没有实现的对象方法-
// resolveInstanceMethod中sel是没有实现的参数
+ (BOOL)resolveInstanceMethod:(SEL)sel{

    NSLog(@&quot;%@&quot;,NSStringFromSelector(sel));
//    if (sel == @selector(eat)) {}这句话等同下面的判断

    if ([NSStringFromSelector(sel) isEqualToString:@&quot;eat:&quot;] ) {
        // 这里添加方法
        // 给哪个类
        //SEL:方法名
        //IMP:方法的实现（函数的入口-函数的指针-函数的名）
        //type :方法类型
        class_addMethod(self, sel, (IMP)eat, &quot;v@:@&quot;); 
        returnYES;
    }
    return [super resolveInstanceMethod:sel];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里介绍一下OBJC_EXPORT BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)这个函数的参数意义&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Class cls:就是你给哪个类添加的这个方法
SEL name：就是方法名字是啥，默认进入方法的时候，肯定是方法上带的参数sel没有，所以我们这里传入的是sel。
(IMP)eat：这里需要我们传入一个IMP，啥实IMP,IMP就是方法的实现（函数的入口-函数的指针-函数的名）大家这里意会下
 const char *types，这里我们可以好好说一说。我先说下意思，*v@:@*的意思就是，返回类型是void,参数是id,SEL,id。具体大家参考上面我写的函数以及函数说明。

如果想查到这些代表啥意思，可以打开苹果文档，输入Type Encodings，选择我箭头所指。查询。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/joshpell/G5YKO1rz/BI7j7.png&quot; alt=&quot;Thumper&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;动态添加属性&quot;&gt;动态添加属性&lt;/h3&gt;
&lt;p&gt;通过运行时添加属性，使用面还是比较广的。比如想给button类绑定一个属性，大家肯定会继承button来操作。其实通过运行时添加属性，我们就可以实现给系统button添加一个属性的需求。&lt;/p&gt;

&lt;p&gt;默认我们在创建分类的时候，添加一个成员属性后，大家往往会发现，直接调用这个类的点语法，我们获取不了属性,为什么呢？&lt;/p&gt;

&lt;p&gt;因为默认分类创建的属性，不会执行set和get方法。如果我们一定要获取到这个属性，我们应该怎么做呢？这里有2种方法，一种就是添加一个静态变量，重写它的set和get方法.另外一种就是通过运行时，添加这个属性。这里我只讲第二种，代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 声明一个char型的key
static char nameKey;

- (void)setName:(NSString *)name
{
    // 属性跟对象有关联-就是添加属性

    // object:对象
    // key:属性名，根据key去获取到值
    // value:值
    // policy：策略
    objc_setAssociatedObject(self, &amp;amp;nameKey, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里我讲一下OBJC_EXPORT void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)这个方法。&lt;/p&gt;

&lt;p&gt;这个方法的字面意思就是把一个值，通过一个key绑定到一个类中，最后设置一下保存的策略。代码的意思是，把name的值，通过nameKey绑定到当前类，保存的是nonatomic的copy类型。
补充一下最后一个参数（策略）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// assign类型
   OBJC_ASSOCIATION_ASSIGN = 0,
// 非原子性Retain--&amp;gt;相当于Strong
    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1,
// 非原子性 copy-
    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,
// 原子性Retain
    OBJC_ASSOCIATION_RETAIN = 01401,
// 原子性copy
    OBJC_ASSOCIATION_COPY
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;取得动态绑定属性的方法如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (NSString *)name
{
    return objc_getAssociatedObject(self, &amp;amp;nameKey);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;简单的解释就是通过self这个类的，nameKey这个key,我们就可以取到nameKey相对应的值了。这就是如何通过runtime来动态的给类添加属性了，帅哥，你可以试试了！&lt;/p&gt;

</description>
        <pubDate>Mon, 12 Dec 2016 16:08:08 +0800</pubDate>
        <link>http://localhost:4000/study/2016/12/12/RunTime%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7/</link>
        <guid isPermaLink="true">http://localhost:4000/study/2016/12/12/RunTime%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7/</guid>
        
        <category>runtime</category>
        
        <category>动态添加</category>
        
        <category>RunTime动态添加方法和属性</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>xib作为cell时的复用问题</title>
        <description>&lt;p&gt;apple鼓励大家使用图形化界面开发，这样效率更高，但我们在使用xib新建cell的时候会遇到问题,xib新建时是没有&lt;code class=&quot;highlighter-rouge&quot;&gt;initWithStyle: reuseIdentifier:&lt;/code&gt;这个方法的，但为了效率cell还是需要复用，所以就需要用下面方法来新建cell了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    MyCustomCell * cell = [tableView dequeueReusableCellWithIdentifier:@&quot;myCell&quot;];
    if (!cell){
    
        [tableView registerNib:[UINib nibWithNibName:@&quot;MyCustomCell&quot; bundle:nil] forCellReuseIdentifier:@&quot;myCell&quot;];
        cell = [tableView dequeueReusableCellWithIdentifier:@&quot;myCell&quot;];
    }
    return cell;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Mon, 12 Dec 2016 16:08:08 +0800</pubDate>
        <link>http://localhost:4000/tips/2016/12/12/xib%E4%BD%9C%E4%B8%BAcell%E6%97%B6%E7%9A%84%E5%A4%8D%E7%94%A8%E9%97%AE%E9%A2%98/</link>
        <guid isPermaLink="true">http://localhost:4000/tips/2016/12/12/xib%E4%BD%9C%E4%B8%BAcell%E6%97%B6%E7%9A%84%E5%A4%8D%E7%94%A8%E9%97%AE%E9%A2%98/</guid>
        
        <category>xib</category>
        
        <category>复用</category>
        
        <category>xib作为cell时的复用问题</category>
        
        
        <category>tips</category>
        
      </item>
    
      <item>
        <title>WKWebKit介绍</title>
        <description>&lt;p&gt;苹果在iOS8推出了一个新的框架&lt;code class=&quot;highlighter-rouge&quot;&gt;WKWebKit&lt;/code&gt;，更好地内存优化、更快的加载速度和更丰富的接口让它成为了开发者手中的香馍馍，替代UIWebView就变得顺理成章。&lt;/p&gt;

&lt;p&gt;UIWebView&amp;amp;UIWebDelegate这两个东西在WKWebKit中被重构成16个类、3个协议&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Classes&lt;/em&gt;&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;WKBackForwardList：历史记录列表，可以通过后退和前进动作访问到；（- itemAtIndex: 该类中唯一方法，用于返回项目在指定的距离当前项目。还有backItem、currentItem、forwardItem、backList、forwardList属性）&lt;/li&gt;
  &lt;li&gt;WKBackForwardListItem：webView中后退列表里的某一网页；（有URL、title、initialURL三个属性）&lt;/li&gt;
  &lt;li&gt;WKFrameInfo:包含一个框架在一个网页的信息；（有mainFrame、request、securityOrigin三个属性，其中securityOrigin是一个WKSecurityOrigin对象属性，iOS9之后可使用，是由一个主机名称，协议和端口号组成。）&lt;/li&gt;
  &lt;li&gt;WKNavigation：包含一个网页加载进度信息；&lt;/li&gt;
  &lt;li&gt;WKNavigationAction：包含可能让网页导航变化的信息，用于判断是否做出导航变化；（值得注意的是可能会常用的 WKNavigationType这个枚举）&lt;/li&gt;
  &lt;li&gt;WKNavigationResponse：包含可能让网页导航变化的返回内容信息，用于判断是否做出导航变化；&lt;/li&gt;
  &lt;li&gt;WKPreferences：概括一个webView的偏好设置；（ minimumFontSize、 javaScriptEnabled、 javaScriptCanOpenWindowsAutomatically三个属性，值得注意的是后两个属性，一个决定是否启用javaScript,另一个是在没有用户交互的情况下，是否JavaScript可以打开windows）&lt;/li&gt;
  &lt;li&gt;WKProcessPool：表示一个web内容加载池；&lt;/li&gt;
  &lt;li&gt;WKUserContentController：提供使用JavaScript post信息和注射script的方法。（- addScriptMessageHandler:name: 添加一个消息处理程序脚本 - addUserScript: 添加一个用户脚本 - removeAllUserScripts remove所有用户脚本 —removeScriptMessageHandlerForName: 删除一个消息处理程序的脚本 和一个userScript属性： 与用户相关联的用户脚本内容控制器）&lt;/li&gt;
  &lt;li&gt;WKScriptMessage: 包含网页发出的信息。（body、webView、frameInfo、name）&lt;/li&gt;
  &lt;li&gt;WKUserScript：表示可以被网页接受的用户脚本。&lt;/li&gt;
  &lt;li&gt;WKWebViewConfiguration: 初始化 webview 的设置。（- initWithSource:injectionTime:forMainFrameOnly: 返回一个初始化用户脚本,可以添加到一个用户内容控制器 还有source、injectionTime、forMainFrameOnly）&lt;/li&gt;
  &lt;li&gt;WKWindowFeatures:指定加载新网页时的窗口属性。(全是窗口属性)&lt;/li&gt;
  &lt;li&gt;WKWebViewConfiguration:对象是属性的集合用来初始化一个web视图。(属性比较多，不过这个对象在初始化web视图的时候必须会用到)&lt;/li&gt;
  &lt;li&gt;还有WKWebsiteDataStore&amp;amp;WKWebsiteDataRecord两个类&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Protocols&lt;/em&gt;&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;WKNavigationDelegate:提供了追踪主窗口网页加载过程和判断主窗口和子窗口是否进行页面加载新页面的相关方法。&lt;/li&gt;
  &lt;li&gt;WKScriptMessageHandler: 提供从网页中收消息的回调方法。&lt;/li&gt;
  &lt;li&gt;WKUIDelegate: 提供用原生控件显示网页的方法回调。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;WKNavigationDelegate&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;webView:didCommitNavigation: 主框架在内容开始到达时调用。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;webView:didFailNavigation:withError: 主框架导航发生错误时调用。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;webView:didFailProvisionalNavigation:withError: 主框架在开始加载数据出现错误时调用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;webView:didFinishNavigation: 主框架导航完成时调用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;webView:didReceiveAuthenticationChallenge:completionHandler: web视图需要响应身份验证时调用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;webView:didReceiveServerRedirectForProvisionalNavigation: 主服务器接受到重定向时调用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;webView:didStartProvisionalNavigation: 主框架导航开始时调用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;webView:decidePolicyForNavigationAction:decisionHandler: 决定是否允许或取消一个导航&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;webView:decidePolicyForNavigationResponse:decisionHandler: 决定是否允许或取消一个导航后其反应是已知的&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;WKScriptMessageHandler&lt;/em&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;userContentController:didReceiveScriptMessage:（required）一个脚本从一个网页接收到消息时调用&lt;/li&gt;
  &lt;li&gt;WKUIDelegate：&lt;/li&gt;
  &lt;li&gt;webView:createWebViewWithConfiguration:forNavigationAction:windowFeatures:创建一个新的webView&lt;/li&gt;
  &lt;li&gt;webView:runJavaScriptAlertPanelWithMessage:initiatedByFrame:completionHandler: 显示一个JavaScript警告面板。&lt;/li&gt;
  &lt;li&gt;webView:runJavaScriptConfirmPanelWithMessage:initiatedByFrame:completionHandler:显示一个JavaScript确认面板。&lt;/li&gt;
  &lt;li&gt;webView:runJavaScriptTextInputPanelWithPrompt:defaultText:initiatedByFrame:completionHandler: 显示一个JavaScript文本输入面板。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中一些类中的枚举状态：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef NS_ENUM(NSInteger, WKNavigationType) {
    WKNavigationTypeLinkActivated,//链接的href属性被用户激活。
    WKNavigationTypeFormSubmitted,//一个表单提交。
    WKNavigationTypeBackForward,//回到前面的条目列表请求。
    WKNavigationTypeReload,//网页加载。
    WKNavigationTypeFormResubmitted,//一个表单提交(例如通过前进,后退,或重新加载)。
    WKNavigationTypeOther = -1,//导航是发生一些其他原因。
} NS_ENUM_AVAILABLE(10_10, 8_0);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef NS_ENUM(NSInteger, WKUserScriptInjectionTime) {
    WKUserScriptInjectionTimeAtDocumentStart,//注入后的脚本创建文档元素,但在其他任何内容已经被加载。
    WKUserScriptInjectionTimeAtDocumentEnd//注入脚本文档完成加载后,但在任何子资源可能完成加载。
}
NS_ENUM_AVAILABLE(10_10, 8_0);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef NS_ENUM(NSInteger, WKNavigationActionPolicy) {
    WKNavigationActionPolicyCancel,//取消导航
    WKNavigationActionPolicyAllow,//允许导航继续
} NS_ENUM_AVAILABLE(10_10, 8_0);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef NS_ENUM(NSInteger, WKNavigationResponsePolicy) {
    WKNavigationResponsePolicyCancel,//取消导航
    WKNavigationResponsePolicyAllow,//允许导航继续
} NS_ENUM_AVAILABLE(10_10, 8_0);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Mon, 12 Dec 2016 16:08:08 +0800</pubDate>
        <link>http://localhost:4000/study/2016/12/12/WKWebKit%E4%BB%8B%E7%BB%8D/</link>
        <guid isPermaLink="true">http://localhost:4000/study/2016/12/12/WKWebKit%E4%BB%8B%E7%BB%8D/</guid>
        
        <category>WKWebKit</category>
        
        <category>WKWebKit介绍</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>emoji表情作为单字符长度的处理</title>
        <description>&lt;p&gt;我们知道emoji表情是一些特殊格式的字符串，因此我们在计算其长度的时候直接用“xxx.length”即可，但有时候产品经理会要求你把所有的emoji表情都当做一个字符处理，别问我怎么知道的😭😭😭，这里写下来希望大家不要跟我一样到处跳坑&lt;/p&gt;

&lt;p&gt;还是直接上代码&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;获取emoji个数（我这里写到了NSString的类方法中）&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
+ (NSInteger)emojiCountInString:(NSString *)string
{
    __block NSInteger num = 0;
    [string enumerateSubstringsInRange:NSMakeRange(0, [string length])
                               options:NSStringEnumerationByComposedCharacterSequences
                            usingBlock:^(NSString * _Nullable substring, NSRange substringRange, NSRange enclosingRange, BOOL * _Nonnull stop) {
		const unichar hs = [substring characterAtIndex:0];
		if (0xd800 &amp;lt;= hs &amp;amp;&amp;amp; hs &amp;lt;= 0xdbff){
			if (substring.length &amp;gt; 1) {
				const unichar ls = [substring characterAtIndex:1];
			    const int uc = ((hs - 0xd800) * 0x400) + (ls - 0xdc00) + 0x10000;
				if (0x1d000 &amp;lt;= uc &amp;amp;&amp;amp; uc &amp;lt;= 0x1f918)
				{
					num += 1;
				}
			}
		}
		else if (substring.length &amp;gt; 1)
		{
			const unichar ls = [substring characterAtIndex:1];
			if (ls == 0x20e3 || ls == 0xFE0F || ls == 0xd83c)
			{
				num += 1;
			}
		}
	    else{
		// non surrogate
			if (0x2100 &amp;lt;= hs &amp;amp;&amp;amp; hs &amp;lt;= 0x27ff)
			{
			if (0x278b &amp;lt;= hs &amp;amp;&amp;amp; 0x2792 &amp;gt;= hs)
			{
				//不为emoji
			}
			else
			{
				num += 1;
			}
		}
		else if (0x2B05 &amp;lt;= hs &amp;amp;&amp;amp; hs &amp;lt;= 0x2b07)
		{
			num += 1;
		}
		else if (0x2934 &amp;lt;= hs &amp;amp;&amp;amp; hs &amp;lt;= 0x2935)
		{
			num += 1;
		}
		else if (0x3297 &amp;lt;= hs &amp;amp;&amp;amp; hs &amp;lt;= 0x3299)
		{
			num += 1;
		}
		else if (hs == 0xa9 || hs == 0xae || hs == 0x303d || hs == 0x3030 || hs == 0x2b55 || hs == 0x2b1c || hs == 0x2b1b || hs == 0x2b50 || hs == 0xd83e)
		{
			num += 1;
		}
	}
	}];
    return num;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;字符串去掉emoji&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
+ (NSString *)getStringWithoutEmoji:(NSString *)string
{
    __block NSString *tempStr = string;
    [string enumerateSubstringsInRange:NSMakeRange(0, [string length])
                               options:NSStringEnumerationByComposedCharacterSequences
                            usingBlock:^(NSString * _Nullable substring, NSRange substringRange, NSRange enclosingRange, BOOL * _Nonnull stop) {
                                const unichar hs = [substring characterAtIndex:0];
                                // surrogate pair
                                if (0xd800 &amp;lt;= hs &amp;amp;&amp;amp; hs &amp;lt;= 0xdbff)
                                {
                                    if (substring.length &amp;gt; 1)
                                    {
                                        const unichar ls = [substring characterAtIndex:1];
                                        const int uc = ((hs - 0xd800) * 0x400) + (ls - 0xdc00) + 0x10000;
                                        if (0x1d000 &amp;lt;= uc &amp;amp;&amp;amp; uc &amp;lt;= 0x1f918)
                                        {

                                            tempStr = [tempStr stringByReplacingOccurrencesOfString:substring withString:@&quot;&quot;];
                                        }
                                    }
                                }
                                else if (substring.length &amp;gt; 1)
                                {
                                    const unichar ls = [substring characterAtIndex:1];
                                    if (ls == 0x20e3 || ls == 0xFE0F || ls == 0xd83c)
                                    {
                                        tempStr = [tempStr stringByReplacingOccurrencesOfString:substring withString:@&quot;&quot;];
                                    }
                                }
                                else
                                {
                                    // non surrogate
                                    if (0x2100 &amp;lt;= hs &amp;amp;&amp;amp; hs &amp;lt;= 0x27ff)
                                    {
                                        if (0x278b &amp;lt;= hs &amp;amp;&amp;amp; 0x2792 &amp;gt;= hs)
                                        {
                                            //不为emoji
                                        }
                                        else
                                        {
                                            tempStr = [tempStr stringByReplacingOccurrencesOfString:substring withString:@&quot;&quot;];
                                        }
                                    }
                                    else if (0x2B05 &amp;lt;= hs &amp;amp;&amp;amp; hs &amp;lt;= 0x2b07)
                                    {
                                        tempStr = [tempStr stringByReplacingOccurrencesOfString:substring withString:@&quot;&quot;];
                                    }
                                    else if (0x2934 &amp;lt;= hs &amp;amp;&amp;amp; hs &amp;lt;= 0x2935)
                                    {
                                        tempStr = [tempStr stringByReplacingOccurrencesOfString:substring withString:@&quot;&quot;];
                                    }
                                    else if (0x3297 &amp;lt;= hs &amp;amp;&amp;amp; hs &amp;lt;= 0x3299)
                                    {
                                        tempStr = [tempStr stringByReplacingOccurrencesOfString:substring withString:@&quot;&quot;];
                                    }
                                    else if (hs == 0xa9 || hs == 0xae || hs == 0x303d || hs == 0x3030 || hs == 0x2b55 || hs == 0x2b1c || hs == 0x2b1b || hs == 0x2b50 || hs == 0xd83e)
                                    {
                                        tempStr = [tempStr stringByReplacingOccurrencesOfString:substring withString:@&quot;&quot;];
                                    }
                                }
                            }];
    return tempStr;
}



&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;获取把emoji表情当成单个字符长度处理后的字符串长度&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-(NSInteger)lengthWithEmojiString{
    NSInteger emojiLen = [NSString emojiCountInString:self];
    NSString * normalStr = [NSString getStringWithoutEmoji:self];
    NSInteger strLengh = normalStr.length+emojiLen;
    return strLengh;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 08 Nov 2016 16:08:08 +0800</pubDate>
        <link>http://localhost:4000/study/2016/11/08/emoji%E8%A1%A8%E6%83%85%E4%BD%9C%E4%B8%BA%E5%8D%95%E5%AD%97%E7%AC%A6%E9%95%BF%E5%BA%A6%E7%9A%84%E5%A4%84%E7%90%86/</link>
        <guid isPermaLink="true">http://localhost:4000/study/2016/11/08/emoji%E8%A1%A8%E6%83%85%E4%BD%9C%E4%B8%BA%E5%8D%95%E5%AD%97%E7%AC%A6%E9%95%BF%E5%BA%A6%E7%9A%84%E5%A4%84%E7%90%86/</guid>
        
        <category>emoji</category>
        
        <category>长度</category>
        
        <category>emoji表情作为单字符长度的处理</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>block中weakSelf和strongSelf的简化</title>
        <description>&lt;p&gt;我们知道在block中使用全局变量需要考虑到循环引用问题，这时就会引入weakSelf和strongSelf，具体用法不多说，网上很多介绍的文章，比如&lt;a href=&quot;http://www.jianshu.com/p/701da54bd78c&quot;&gt;深入研究Block用weakSelf、strongSelf、@weakify、@strongify解决循环引用&lt;/a&gt;
  但是频繁的书写weakSelf和strongSelf会让人觉得代码重复，但是这个东西又不好抽取。经过多方打探，找到一个特别简便的方法，你不用再考虑weakSelf和strongSelf的书写，直接使用self代替即可。在文件中加入下面的宏即可。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define weakify(...) \
    ext_keywordify \
    metamacro_foreach_cxt(ext_weakify_,, __weak, __VA_ARGS__)
#define strongify(...) \
    ext_keywordify \
    _Pragma(&quot;clang diagnostic push&quot;) \
    _Pragma(&quot;clang diagnostic ignored \&quot;-Wshadow\&quot;&quot;) \
    metamacro_foreach(ext_strongify_,, __VA_ARGS__) \
    _Pragma(&quot;clang diagnostic pop&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 18 Oct 2016 16:08:08 +0800</pubDate>
        <link>http://localhost:4000/efficiency/2016/10/18/block%E4%B8%ADweakSelf%E5%92%8CstrongSelf%E7%9A%84%E7%AE%80%E5%8C%96/</link>
        <guid isPermaLink="true">http://localhost:4000/efficiency/2016/10/18/block%E4%B8%ADweakSelf%E5%92%8CstrongSelf%E7%9A%84%E7%AE%80%E5%8C%96/</guid>
        
        <category>循环引用</category>
        
        <category>block</category>
        
        <category>self</category>
        
        <category>block中weakSelf和strongSelf的简化</category>
        
        
        <category>Efficiency</category>
        
      </item>
    
      <item>
        <title>OC升序与降序排列数组</title>
        <description>&lt;p&gt;对数组进行快速升降序排列,话不多说直接上代码&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;升序&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSArray *tMlist = @[@4,@5,@2,@6,@3,@7,@8];
NSArray *tArray = [tMlist sortedArrayUsingComparator:^NSComparisonResult(id obj1, id obj2) {
     NSNumber *tNumber1 = (NSNumber *)obj1;
     NSNumber *tNumber2 = (NSNumber *)obj2; //升序2，4，。。
     if ([tNumber1 integerValue] &amp;lt; [tNumber2 integerValue]){
          return NSOrderedAscending;
     }else{
          return NSOrderedDescending;
     }
}];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;降序&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSArray *tMlist = @[@4,@5,@2,@6,@3,@7,@8];
NSArray *tArray = [tMlist sortedArrayUsingComparator:^NSComparisonResult(id obj1, id obj2) {
     NSNumber *tNumber1 = (NSNumber *)obj1;
     NSNumber *tNumber2 = (NSNumber *)obj2; //降序序8，7，。。
     if ([tNumber1 integerValue] &amp;lt; [tNumber2 integerValue]){
          return NSOrderedDescending;
     }else{
          return NSOrderedAscending;
     }
}];

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 18 Oct 2016 16:08:08 +0800</pubDate>
        <link>http://localhost:4000/efficiency/2016/10/18/OC%E5%8D%87%E5%BA%8F%E4%B8%8E%E9%99%8D%E5%BA%8F%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84/</link>
        <guid isPermaLink="true">http://localhost:4000/efficiency/2016/10/18/OC%E5%8D%87%E5%BA%8F%E4%B8%8E%E9%99%8D%E5%BA%8F%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84/</guid>
        
        <category>oc排序</category>
        
        <category>升序降序</category>
        
        <category>OC升序与降序排列数组</category>
        
        
        <category>Efficiency</category>
        
      </item>
    
      <item>
        <title>cornerstone永久破解</title>
        <description>&lt;p&gt;有截图就不码蚊子了😁&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/joshpell/G5Qw8sv9/Qvlnf.png&quot; alt=&quot;Thumper&quot; /&gt;
&lt;img src=&quot;http://pic.yupoo.com/joshpell/G5Qw8GrN/qLFGC.png&quot; alt=&quot;Thumper&quot; /&gt;
&lt;img src=&quot;http://pic.yupoo.com/joshpell/G5Qw8A6m/SFQ1X.png&quot; alt=&quot;Thumper&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 14 Oct 2016 16:08:08 +0800</pubDate>
        <link>http://localhost:4000/tips/2016/10/14/cornerstone%E6%B0%B8%E4%B9%85%E7%A0%B4%E8%A7%A3/</link>
        <guid isPermaLink="true">http://localhost:4000/tips/2016/10/14/cornerstone%E6%B0%B8%E4%B9%85%E7%A0%B4%E8%A7%A3/</guid>
        
        <category>cornerstone</category>
        
        <category>破解</category>
        
        <category>cornerstone永久破解</category>
        
        
        <category>tips</category>
        
      </item>
    
      <item>
        <title>代码的特殊注释</title>
        <description>&lt;p&gt;用“///”和“#param mark”来给代码做注释很常见，下面介绍几个不常见的注释方法，中高级程序员必备！&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;TODO: + 说明：
如果代码中有该标识，说明在标识处有功能代码待编写，待实现的功能在说明中会简略说明。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;FIXME: + 说明：
如果代码中有该标识，说明标识处代码需要修正，甚至代码是错误的，不能工作，需要修复，如何修正会在说明中简略说明。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;XXX: + 说明：
如果代码中有该标识，说明标识处代码虽然实现了功能，但是实现的方法有待商榷，希望将来能改进，要改进的地方会在说明中简略说明。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;eclipse中特殊的注释：
在eclipse中，TODO、FIXME和XXX都会被eclipse的task视图所收集。在项目发布前，检查一下task视图是一个很好的习惯。此外，在eclipse中，我们可自定义自己的特殊注释标签。如在C/C++中，进入window—&amp;gt;preferences—&amp;gt;C/C++—&amp;gt;Task Tags窗口即可添加特殊标签，默认只有TODO、FIXME和XXX。&lt;/p&gt;

</description>
        <pubDate>Sun, 09 Oct 2016 16:08:08 +0800</pubDate>
        <link>http://localhost:4000/tips/2016/10/09/%E4%BB%A3%E7%A0%81%E7%9A%84%E7%89%B9%E6%AE%8A%E6%B3%A8%E9%87%8A/</link>
        <guid isPermaLink="true">http://localhost:4000/tips/2016/10/09/%E4%BB%A3%E7%A0%81%E7%9A%84%E7%89%B9%E6%AE%8A%E6%B3%A8%E9%87%8A/</guid>
        
        <category>代码规范</category>
        
        <category>特殊注释</category>
        
        <category>OC代码的特殊注释</category>
        
        
        <category>tips</category>
        
      </item>
    
  </channel>
</rss>
