<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JoshPell</title>
    <description>欢迎来到我的个人网站~</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 15 Aug 2017 12:01:04 +0800</pubDate>
    <lastBuildDate>Tue, 15 Aug 2017 12:01:04 +0800</lastBuildDate>
    <generator>Jekyll v3.1.1</generator>
    
      <item>
        <title>iOS 9 Universal links 实践</title>
        <description>&lt;p&gt;最近一个多月公司项目UI大改，做的都是大量重复的简单工作，一是没时间二是没有什么新的技术点，唯一遇到的新的值得写个小文章记录一下的就是这个了。&lt;/p&gt;

&lt;h3 id=&quot;universal-links&quot;&gt;Universal links简介&lt;/h3&gt;
&lt;p&gt;Universal links是苹果在WWDC 2015上为iOS 9宣布加入的一个所谓通用链接的深层链接特性，&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2015/509/&quot;&gt;视频介绍&lt;/a&gt;和&lt;a href=&quot;https://developer.apple.com/library/content/documentation/General/Conceptual/AppSearch/UniversalLinks.html#//apple_ref/doc/uid/TP40016308-CH12-SW1&quot;&gt;官方说明文档&lt;/a&gt;,官方描述是Deep link，是系统级的跳转功能，通过传统 HTTP 链接来启动 App, 使用相同的网址打开网站和 App。重要的是不需要特别的schema，其他App阻止不了跳转！很多App垂涎已久的流量转化可以实现了！&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;流程简述&lt;/h3&gt;
&lt;p&gt;现在有一个你公司自己的网页（网址随意，与跳转无关），网页上有一个“打开App”按钮，点击效果是打开一个链接（需要配置，后面详述），若已安装App则直接会打开（苹果系统操作，不用管），若没有则H5延时判断跳转苹果商店，结束。这样一个流程对比使用schema来打开App，一是简化了用户的操作，二是不用获取初始App的授权，简直是广大中小App运营者的福音啊&lt;/p&gt;

&lt;h3 id=&quot;universal-links-1&quot;&gt;Universal links使用和配置&lt;/h3&gt;

&lt;p&gt;想使用Universal links说难也不难，但说简单也不简单，它的不简单是由于需要配置的东西比较多，而且一步都不能少，接下来就给大家说一下需要配置哪些东西。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1.（服务器端）一个通过https配置的域名，证书最好不要自制，尽量使用第三方证书，测试方法：用Safari打开该域名，如果中间没有警告提示能直接打开网址，说明证书配置成功&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;2.（服务器端）编辑一个JSON内容格式的文件，放到上面配置好的域名子目录下，苹果规定是域名的根目录或者是well-known目录下，测试方法：浏览器打开https://&amp;lt;domain&amp;gt;/apple-app-site-association 或者 https://&amp;lt;domain&amp;gt;/.well-known/apple-app-site-association能看到你的JSON文件的内容，苹果会在适当的时候去访问这个文件，以此来决定你的跳转能否支持，文件内容如下：&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;applinks&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;apps&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;details&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;appID&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;9JA89QQLNQ.com.apple.wwdc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;paths&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;/wwdc/news/&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;/videos/wwdc/2015/*&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;appID&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ABCD1234.com.apple.wwdc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;paths&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;*&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;
参数说明：&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;apps&quot;: [],&lt;/code&gt;格式固定，不用修改；&lt;code class=&quot;highlighter-rouge&quot;&gt;details&lt;/code&gt;：本域名支持跳转的app信息（如公司旗下App不止一个，则需挨个配置）；&lt;code class=&quot;highlighter-rouge&quot;&gt;appID&lt;/code&gt;:格式为“&lt;code class=&quot;highlighter-rouge&quot;&gt;teamID&lt;/code&gt;. &lt;code class=&quot;highlighter-rouge&quot;&gt;bundle id&lt;/code&gt;”（打开苹果开发者中心，登陆自己账号，identifiers-&amp;gt;App IDs,点击该App使用的ID即可看到）；&lt;code class=&quot;highlighter-rouge&quot;&gt;paths&lt;/code&gt;：支持跳转的网址目录，“*”表示配置网址的所有子目录都支持跳转。&lt;/p&gt;

&lt;p&gt;这一步有个&lt;a href=&quot;https://search.developer.apple.com/appsearch-validation-tool/&quot;&gt;官方测试方法&lt;/a&gt;，但仅做参考，因为我配置好App端和服务器端，都能打开App了，这个测试网址还检测我的配置网址有问题。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;3.（App端）打开你项目targets-&amp;gt;Capabilities下的Associated Domains开关，并将你前面配置的域名添加到这里，支持添加多个域名，如图：&lt;/code&gt;
&lt;img src=&quot;http://cc.cocimg.com/api/uploads/20150902/1441166240882211.png&quot; width=&quot;400&quot; height=&quot;&quot; alt=&quot;photos&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;4.（App端）以上东西配置好后一定不要忘了这一步，更新Certificates证书到项目中！删除原有钥匙串管理中的证书，下载安装新的证书&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;5.（App端）这个应该写在第一点，就是本功能仅支持iOS 9 beta 2和Xcode 7 beta 2及以上版本&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;6.(App端)如果前面几步都做正确的话，这时候你已经能从H5打开App了，这时候就需要来实现App端的功能了，如果需求是打开App后会有相关操作，则需要实现**- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void (^)(NSArray * _Nullable))restorationHandler**方法了，通过代码**NSURL *url = userActivity.webpageURL**可以获取本次跳转的链接信息，App端可以和其约定参数进行后续操作&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Universal links工作流程：
&lt;img src=&quot;http://cc.cocimg.com/api/uploads/20150902/1441174097574453.png&quot; width=&quot;400&quot; height=&quot;&quot; alt=&quot;photos&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以上几步就能确保你的App能在iOS9以后的系统中打开了，enjoy your self!&lt;/p&gt;

&lt;h3 id=&quot;universal-links-2&quot;&gt;Universal links缺点&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1.只适用于iOS 9+，大型App有许多低版本用户，不适用&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;2.总会进入到先前App所在的页面，如果需求是在特定界面，会需要一些额外操作&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;3.必须拥有并维护一个网站，许多小型App或个人开发者无法负担&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;第三方解决方案&lt;/h3&gt;

&lt;p&gt;1.&lt;strong&gt;&lt;a href=&quot;https://hokolinks.com&quot;&gt;HOKO&lt;/a&gt;&lt;/strong&gt;（境外服务上商）&lt;/p&gt;

&lt;p&gt;2&lt;strong&gt;&lt;a href=&quot;http://www.magicwindow.cn&quot;&gt;魔窗&lt;/a&gt;&lt;/strong&gt;（境内服务商）&lt;/p&gt;

</description>
        <pubDate>Mon, 14 Aug 2017 16:08:13 +0800</pubDate>
        <link>/2017/08/iOS-9-Universal-links-%E5%AE%9E%E8%B7%B5/</link>
        <guid isPermaLink="true">/2017/08/iOS-9-Universal-links-%E5%AE%9E%E8%B7%B5/</guid>
        
        <category>Universal links</category>
        
        <category>APP间跳转</category>
        
        <category>Universal links 从微信QQ等其他App跳转到你自己APP的实践</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>如何将自己项目的代码文档导出为苹果样式</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;代码技术文档&lt;/h3&gt;

&lt;p&gt;代码技术文档是很多大公司的必做工作，这一步如果做得好，在后续的开发迭代中会少出现许多bug，而且不管开发人员如何迭代，都能快速地上手新项目，这样就能无形当中降低公司的成本。磨刀不误砍柴工，这个道理谁都懂。但是很多小公司或者是程序员可能会怕麻烦，增加工作量，便不去做这个东西，这就导致了很多小公司两三个或三四个人去维护一个项目，在每次更新迭代的时候都会出现同样的bug或者问题，或者是有人员流动的时候，新入员工需要花大量时间去阅读了解代码，后期还不一定会避免一些老的低级bug。表面上节省了文档编写的时间，但后续为此付出代价的时间比编写时间多许多。还有一种情况是上面英文文章中提到的，就是你如果在App Store上上线了一个APP，然后你需要做其他工作，几个月后你需要给该APP更新一下版本，那时候你再看代码想下手，肯定以为是别人写的，但如果有文档，工作肯定事半功倍了。&lt;/p&gt;

&lt;p&gt;本文将展示如何为一个项目做一个基于web的代码文档。&lt;/p&gt;

&lt;h3 id=&quot;beging&quot;&gt;beging&lt;/h3&gt;

&lt;p&gt;新建一个oc工程，工程名后面会用到，&lt;a href=&quot;https://github.com/JoshPellTan/TJJazzyDocumentForOC&quot;&gt;DEMO&lt;/a&gt;地址&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;文档标注&lt;/h3&gt;

&lt;p&gt;最简单的标注就是双斜杠：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//标注说明的内容
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这种方法也是大家最经常用的，简单方便。如果说对于文档或者整个项目而言，就没有太大用处了，只是说你去仔细看某个类的时候会对你的理解有帮助。&lt;/p&gt;

&lt;p&gt;这里说的代码文档是指使用Xcode能很好的识别，看文档的人也能快速理解，Xcode是支持编程者使用特定的关键字，也叫标记，来对代码进行标注的。高效的标注几个基本要求如下：&lt;/p&gt;

&lt;p&gt;1.Utilities面板的Quick Help Inspector会显示标注
2.当你按下Option键然后点击备注的方法、类或属性名时弹出的帮助菜单 Help Popup 里
3.在代码提示的弹框里面会显示注释信息&lt;/p&gt;

&lt;p&gt;但在Xcode中使用 (⌥ Option + ⌘ Command + /)的组合键快速注释，有参数或者返回值的Xcode会自动识别并帮你添加@param或@return关键字，最牛逼的是注释支持markdown语法，你想怎么描述就怎么描述。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/joshpell/GxnrXGtE/tOArP.png&quot; width=&quot;400&quot; height=&quot;&quot; alt=&quot;photos&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再介绍其他两个关键字&lt;code class=&quot;highlighter-rouge&quot;&gt;@code ... @endcode&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;@remark&lt;/code&gt;，前者是代码标签，可以放一小段代码用于提示等，后者是加粗重点提示。他们在你用&lt;code class=&quot;highlighter-rouge&quot;&gt;option&lt;/code&gt;点击查看的时候才会看到，都是跟在属性说明或者方法说明后面。&lt;/p&gt;

&lt;p&gt;加上这些关键词后，在使用该方法时，&lt;code class=&quot;highlighter-rouge&quot;&gt;option&lt;/code&gt;加单击该方法你就能看到如下图的注释了&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/joshpell/GxnrY4oN/aGNAZ.png&quot; width=&quot;400&quot; height=&quot;&quot; alt=&quot;photos&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里快速分享其他类型的文档注释关键词：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@class&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;后面跟类名，类的描述&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;同上&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@protocol&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;同上，需跟协议名，协议的描述&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;superclass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;本类的父类&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;@classdesign&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;本类使用中需要特别注意的事项，如是单例类&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;@coclass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;合作开发的类&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;枚举这里就不讲了，去看&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;demo&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;吧&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;其他还有一些未涉及的注释希望读者也发掘发掘，并告诉我一下，共同学习&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;web&quot;&gt;导出为基于web样式的代码文档&lt;/h3&gt;

&lt;p&gt;1.首先是安装jazzy：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo gem install jazzy
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输入密码后等待安装成功，如果安装不成功，你就得去查查gem版本或ruby环境了，自己google。&lt;/p&gt;

&lt;p&gt;2.使用&lt;/p&gt;

&lt;p&gt;安装成功后cd到所需工程目录下，按顺序输入以下代码，选填表示不是必须输入：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jazzy \
 --objc \
 --author Joshpell（选填） \
 --author_url 你的个人网站地址（选填） \
 --module-version 1.0.0（选填） \
 --umbrella-header PrefixHeader.pch（将你的所有需要文档化的头文件都放pch文件中，这里pch文件是相对路径） \
 --framework-root . \
 --output （文档输出相对路径，一般是工程文件夹新建一个docs：工程相对路径/docs） 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输入完成，回车，等待片刻即可。
成功后工程文件夹会多一个docs文件夹，打开index.html就可以浏览你的代码文档了，如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/joshpell/GxnrXN6O/dIkqQ.png&quot; width=&quot;400&quot; height=&quot;&quot; alt=&quot;photos&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/joshpell/GxnrXKfv/CqPas.png&quot; width=&quot;400&quot; height=&quot;&quot; alt=&quot;photos&quot; /&gt;&lt;/p&gt;

&lt;p&gt;jazzy默认支持swift，如果你是swift项目，恭喜你了，cd到工程目录下，一行代码搞定(感觉OC受到了歧视。。。)：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jazzy --min-acl internal
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果你是特定版本的swift，可能会看不到jazzy输出，就只能用特定版本的命令输出：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jazzy --swift-version x.x.x --min-acl internal--
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果你想像OC一样加入更详细的文档描述，参考下面命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jazzy \
  --clean \
  --author Realm \
  --author_url https://realm.io \
  --github_url https://github.com/realm/realm-cocoa \
  --github-file-prefix https://github.com/realm/realm-cocoa/tree/v0.96.2 \
  --module-version 0.96.2 \
  --xcodebuild-arguments -scheme,RealmSwift \
  --module RealmSwift \
  --root-url https://realm.io/docs/swift/0.96.2/api/ \
  --output docs/swift_output \
  --theme docs/themes
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;有一点是非常牛逼的，你导出的文档它会自动生成一个swift代码版本的参照！
&lt;a href=&quot;https://github.com/JoshPellTan/TJJazzyDocumentForOC&quot;&gt;DEMO&lt;/a&gt;地址，如果觉得对你有帮助别忘了star一个，共同学习，共同进步！&lt;/p&gt;

&lt;p&gt;参考&lt;a href=&quot;http://www.appcoda.com/documenting-source-code-in-xcode/#disqus_thread&quot;&gt;Documenting Your Objective-C and Swift Code in Xcode with HeaderDoc and Doxygen&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 21 Jun 2017 16:08:13 +0800</pubDate>
        <link>/2017/06/%E5%A6%82%E4%BD%95%E5%B0%86%E8%87%AA%E5%B7%B1%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%BB%A3%E7%A0%81%E6%96%87%E6%A1%A3%E5%AF%BC%E5%87%BA%E4%B8%BA%E8%8B%B9%E6%9E%9C%E6%A0%B7%E5%BC%8F/</link>
        <guid isPermaLink="true">/2017/06/%E5%A6%82%E4%BD%95%E5%B0%86%E8%87%AA%E5%B7%B1%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%BB%A3%E7%A0%81%E6%96%87%E6%A1%A3%E5%AF%BC%E5%87%BA%E4%B8%BA%E8%8B%B9%E6%9E%9C%E6%A0%B7%E5%BC%8F/</guid>
        
        <category>文档</category>
        
        <category>如何将自己项目的代码文档导出为苹果样式（本文以OC为例）</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>gif图片制作相关</title>
        <description>&lt;p&gt;今年是GIF图片诞生30周年，而且一直对iOS的GIF图片比较感兴趣，前两天就花了点时间研究了一下，在此跟大家分享，共同学习，共同进步！
大家也可以直接看&lt;a href=&quot;https://github.com/JoshPellTan/TJGifMaker&quot;&gt;DEMO&lt;/a&gt;，里面在关键地方都有注释。&lt;/p&gt;

&lt;h3 id=&quot;gif&quot;&gt;gif图片本质&lt;/h3&gt;
&lt;p&gt;GIF图片其实和jpg图片一样，是一种流行的图形文件格式。但大家不要以为GIF都是动图，它也是有静态的，只不过我们通常看到的都是动的图片，所以下意识地人为GIF都是动图。&lt;/p&gt;

&lt;h3 id=&quot;gif-1&quot;&gt;gif动图&lt;/h3&gt;
&lt;p&gt;我们主要来研究GIF动图，其实它就是一个图片连续播放的效果而已，只不过这不是我们手动来实现的，各个平台已经对它进行了适配，只要是动图它就能动起来而已。tom猫不知大家玩过没有，它就用的是自己手动展示多张连环图片的方法来实现的动画。&lt;/p&gt;

&lt;h3 id=&quot;gif-2&quot;&gt;gif动图制作&lt;/h3&gt;

&lt;p&gt;这里提供两种方法，一种是偏底层一点需要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Core&lt;/code&gt;框架的方法，另一种是读&lt;code class=&quot;highlighter-rouge&quot;&gt;SDWebImage&lt;/code&gt;源码找到的苹果封装好的方法.&lt;/p&gt;

&lt;p&gt;1.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    //创建gif路
    NSURL * gifPath = [self gifPathURL];

    //图像目标
    CGImageDestinationRef destination = CGImageDestinationCreateWithURL((__bridge CFURLRef)gifPath, kUTTypeGIF, imagePathArray.count, NULL);
    
    //gif设置
    NSDictionary *fileProperties = @{
                                     (__bridge id)kCGImagePropertyGIFDictionary:
                                         @{(__bridge id)kCGImagePropertyGIFLoopCount: @0},
                                     (NSString*)kCGImagePropertyGIFHasGlobalColorMap:[NSNumber numberWithBool:YES],
                                     (NSString *)kCGImagePropertyColorModel:(NSString *)kCGImagePropertyColorModelRGB,
                                     (NSString*)kCGImagePropertyDepth:[NSNumber numberWithInt:8]};
    //a float (not double!) in seconds, rounded to centiseconds in the GIF data
    NSDictionary *frameProperties = @{
                                      (__bridge id)kCGImagePropertyGIFDictionary:
                                          @{(__bridge id)kCGImagePropertyGIFDelayTime: [NSNumber numberWithFloat:duration]}};
    
    CGImageDestinationSetProperties(destination, (__bridge CFDictionaryRef)fileProperties);
    
    //合成gif
    for (UIImage *image in imagePathArray)
    {

        CGImageDestinationAddImage(destination, image.CGImage, (__bridge CFDictionaryRef)frameProperties);
    }
    
    CGImageDestinationSetProperties(destination, (__bridge CFDictionaryRef)frameProperties);
    if (!CGImageDestinationFinalize(destination)) {
        NSLog(@&quot;failed to finalize image destination&quot;);
    }
    
    CFRelease(destination);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;UIImage *animatedImage;
    CGFloat totalTime;
    if (!duration) {
        
        totalTime = (3.0f / 10.0f) * imageArr.count;
    }else{
     
        duration = duration * imageArr.count;
    }
    
    animatedImage = [UIImage animatedImageWithImages:imageArr duration:duration];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;gif-3&quot;&gt;gif图片分解&lt;/h3&gt;
&lt;p&gt;GIF动图是多张图片合成的，当然也有方法将其中的图片一张一张分解出来，注释比较详细，就不多说了。代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//用于保存所有图片
NSMutableArray *imgObjects = [NSMutableArray array];

//1.gif转换成data
NSData *gifData=[NSData dataWithContentsOfFile:gifPath];

//2.通过data获取image的数据源
CGImageSourceRef source =CGImageSourceCreateWithData((CFDataRef)gifData, NULL);

//3.获取gif帧数
size_t count = CGImageSourceGetCount(source);
for (int i=0; i&amp;lt;count; i++) {
    
//4.获取单帧图片
CGImageRef imageRef = CGImageSourceCreateImageAtIndex(source, i, NULL);
    
//5.根据CGImageRef获取图片
//[UIScreen mainScreen].scale    是计算屏幕分辨率的
//UIImageOrientationUp           指定新的图像的绘制方向
UIImage *image = [UIImage imageWithCGImage:imageRef scale:[UIScreen mainScreen].scale orientation:UIImageOrientationUp];
    
//6.释放CGImageRef对象
CGImageRelease(imageRef);

[imgObjects addObject:image];
//释放source
CFRelease(source);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;giftips&quot;&gt;gif使用tips&lt;/h3&gt;

&lt;p&gt;GIF动图的合成和分解比较简单，但使用过程中会有一些小问题，比如你想把制作的GIF放到微信中跟好友秀一下，那么你就必须要控制GIF图片的大小和质量了，否则会失败。还有如何直接用视频制作GIF，取视频中的帧图片拿来合成即可，如何取视频图片我在&lt;a href=&quot;https://joshpelltan.github.io/2017/03/仿微信朋友圈视频剪切功能/&quot;&gt;仿微信朋友圈视频剪切功能&lt;/a&gt;已经讲过。本&lt;a href=&quot;https://github.com/JoshPellTan/TJGifMaker&quot;&gt;DEMO&lt;/a&gt;实现了照片选取转GIF、视频选取或拍摄转GIF、GIF分解为图片等功能，有兴趣的朋友可以下载看一下，觉得不错或对您有帮助的话请&lt;a href=&quot;https://joshpelltan.github.io/2017/03/仿微信朋友圈视频剪切功能/&quot;&gt;star&lt;/a&gt;一个!!!&lt;/p&gt;

&lt;p&gt;如有不足或缺陷敬请指正，共同学习，共同进步！&lt;/p&gt;

</description>
        <pubDate>Mon, 19 Jun 2017 16:08:13 +0800</pubDate>
        <link>/2017/06/gif%E5%9B%BE%E7%89%87%E5%88%B6%E4%BD%9C%E7%9B%B8%E5%85%B3/</link>
        <guid isPermaLink="true">/2017/06/gif%E5%9B%BE%E7%89%87%E5%88%B6%E4%BD%9C%E7%9B%B8%E5%85%B3/</guid>
        
        <category>gif</category>
        
        <category>gif图片制作相关</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>自定义表视图刷新和加载控件</title>
        <description>&lt;p&gt;听传言说公司准备使用自定义的上拉和下拉控件，以前研究过，但没有用到实际项目中，不管传言是真是假，重新学习，继续进步！这里也贴出我写的&lt;a href=&quot;https://github.com/JoshPellTan/TJRefresh&quot;&gt;DEMO&lt;/a&gt;，欢迎使用和Star！&lt;/p&gt;

&lt;p&gt;刷新和加载控件原理是一样，这里就只讲刷新控件，我们先不去研究效果，先来分析一下功能实现，一个常用的刷新控件工作分以下几步：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1.拖动表视图下拉，控件跟随滑动视图慢慢出现&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2.滑动到限定距离，直接松手就触发刷新动作，开始刷新，刷新效果停留顶端；若未松手继续滑动到限定距离以内，不执行操作&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;3.刷新完成，去掉刷新效果，视图恢复原位&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section&quot;&gt;添加控件到每个滑动视图&lt;/h3&gt;

&lt;p&gt;首先如果是给一个成熟的项目加上刷新控件，不可能在每个有滑动视图的类中都去添加刷新控件，怎么办呢？滑动视图都有个共同点，都继承自&lt;code class=&quot;highlighter-rouge&quot;&gt;UIScroolView&lt;/code&gt;，所以这里咱们采用给&lt;code class=&quot;highlighter-rouge&quot;&gt;UIScroolView&lt;/code&gt;类新建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;TJRefresher&lt;/code&gt;的分类，再给分类添加咱们需要的&lt;code class=&quot;highlighter-rouge&quot;&gt;header&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;footer&lt;/code&gt;属性，再在我们需要的滑动视图类中调用这两个属性即可。但是分类中是不能直接添加属性的，咋办，直接不行来间接呗，这里就要用到运行时了，前面讲过&lt;a href=&quot;https://joshpelltan.github.io/2016/12/RunTime动态添加方法和属性/&quot;&gt;如何动态添加属性&lt;/a&gt;，这里不再细讲。上代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static const void *TJRefreshHeaderKey = &amp;amp;TJRefreshHeaderKey;

- (void)setHeader:(TJRefreshHeader *)header {
    
    if (self.header != header) {
        [self.header removeFromSuperview];
        [self insertSubview:header atIndex:0];
        
    }
    objc_setAssociatedObject(self, TJRefreshHeaderKey, header, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

- (TJRefreshHeader *)header {
    return objc_getAssociatedObject(self, &amp;amp;TJRefreshHeaderKey);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里我用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;insertSubview: atIndex:&lt;/code&gt;方法而不是&lt;code class=&quot;highlighter-rouge&quot;&gt;addSubview:&lt;/code&gt;，他们的区别是前者是将视图插入同一个层级，并且可以插队，而后者只能是一层一层往上叠。当一个滑动视图同时添加刷新和加载控件时，前者可以保证他们是在一个视图层级，方便统一处理。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;监听滑动视图，改变控件状态&lt;/h3&gt;

&lt;p&gt;这里需要使用KVO监听滑动视图的滑动距离，有两个选择，一个是放在上面的分类中实现，另一个是放在刷新控件类中实现。前者需要刷新控件暴露很多方法和属性供外部调用，后者只需要将当前滑动视图传递给刷新控件类进行操作即可，权衡后选后者。&lt;/p&gt;

&lt;p&gt;首先重写&lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt;类的方法，将滑动视图取到当前类暂存，并根据该视图调整控件的位置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)willMoveToSuperview:(UIView *)newSuperview {
    [super willMoveToSuperview:newSuperview];
    
    if (newSuperview &amp;amp;&amp;amp; [newSuperview isKindOfClass:[UIScrollView class]]) {
        
        [self removeObserver];
        self.scrollView = (UIScrollView *)newSuperview;
        self.center = CGPointMake(self.scrollView.bounds.size.width*0.5, -TJRefreshPullLen*0.5);
       
        [self addObserver];
    }else {
        [self removeObserver];
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里添加KVO时添加了两个属性监听，&lt;code class=&quot;highlighter-rouge&quot;&gt;contentOffset&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;contentSize&lt;/code&gt;，需要说明的是，在刷新控件中其实只需要监听前者即可，后者的监听是在做加载控件的时候，需要根据父滑动视图的内容大小来确定控件位置和计算控件所在状态。这也是两个控件最大的不同。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[self.scrollView addObserver:self forKeyPath:@&quot;contentOffset&quot; options:NSKeyValueObservingOptionNew context:nil];
    [self.scrollView addObserver:self forKeyPath:@&quot;contentSize&quot; options:NSKeyValueObservingOptionNew context:nil];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接下来将监听到的偏移值进行处理，小于极限值什么都不做，大于极限值时松手则进行刷新操作：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CGFloat value = (layerStrokenValue-(TJRefreshPullLen-TJRefreshHeaderHeight)*0.5)/((TJRefreshPullLen+TJRefreshHeaderHeight)*0.5);

//如果不是正在刷新，则渐变动画
if (!self.animating) {
    
    self.draftShapeLayer.strokeEnd = value;
    self.squareShapeLayer.strokeEnd = value;
    self.lineShapeLayer1.strokeEnd = value*2;
    self.lineShapeLayer2.strokeEnd = (value-0.5)*2;
    self.wordsShapeLayer.strokeEnd = value;

}
//如果到达临界点，则执行刷新动画
if (value &amp;gt; 1 &amp;amp;&amp;amp; !self.animating &amp;amp;&amp;amp; !self.scrollView.dragging){
    [self startAnimation];
    if (self.handle) {
        self.handle();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里控件需要暴露一个方法在刷新结束时供滑动视图调用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)endRefreshing {
    
    [self stopAnimation];
    NSLog(@&quot;结束刷新&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ui&quot;&gt;加载控件的UI&lt;/h3&gt;

&lt;p&gt;这里我仿了一个今日头条的刷新控件效果，用到了iOS9和swift3.0后才推出的&lt;code class=&quot;highlighter-rouge&quot;&gt;CAShapeLayer&lt;/code&gt;，结合&lt;code class=&quot;highlighter-rouge&quot;&gt;UIBezierPath&lt;/code&gt;绘制出了图形的线条和路径，再通过上面的滑动监听去控制线条颜色的填充百分比。这一步骤没有太复杂的逻辑，熟悉上面两个类的使用即可，不细讲，有兴趣可以研究&lt;a href=&quot;https://github.com/JoshPellTan/TJRefresh&quot;&gt;demo&lt;/a&gt;。我还添加了一个文字转贝塞尔曲线的方法，也可以研究一下。&lt;/p&gt;

&lt;p&gt;到这里一个刷新控件就定制完成了，只贴出了一些需要注意的地方的代码，加载控件添加也类似。这里只实现了一个效果，后期如果碰到了好的效果，我还会继续添加的（前提是我会😁）。&lt;/p&gt;

&lt;p&gt;广告时间：觉得不错，欢迎&lt;a href=&quot;https://github.com/JoshPellTan/TJRefresh&quot;&gt;Star&lt;/a&gt;！&lt;/p&gt;

</description>
        <pubDate>Thu, 25 May 2017 16:08:13 +0800</pubDate>
        <link>/2017/05/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%91%E5%8A%A8%E8%A7%86%E5%9B%BE%E5%88%B7%E6%96%B0%E5%92%8C%E5%8A%A0%E8%BD%BD%E6%8E%A7%E4%BB%B6/</link>
        <guid isPermaLink="true">/2017/05/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%91%E5%8A%A8%E8%A7%86%E5%9B%BE%E5%88%B7%E6%96%B0%E5%92%8C%E5%8A%A0%E8%BD%BD%E6%8E%A7%E4%BB%B6/</guid>
        
        <category>刷新</category>
        
        <category>加载</category>
        
        <category>自定义滑动视图刷新和加载控件</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>录音与播放以及网络音频播放</title>
        <description>&lt;p&gt;公司下个版本计划要做音频的录制与播放，这块没怎么接触过，一边学习一边踩坑，下面就给大家做个分享，共同进步。这里也贴出我写的&lt;a href=&quot;https://github.com/JoshPellTan/TJAudioRecorderAndPlayer&quot;&gt;DEMO&lt;/a&gt;，欢迎使用和star！&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;录音&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;音频任务初始化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们这里用的是NB的AVFoundation框架，这里使用AudioSession来对音频任务做处理，无论是录制还是播放都需要做这一步。初始化任务：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AVAudioSession *session = [AVAudioSession sharedInstance];
            NSError *sessionError;
[session setCategory:AVAudioSessionCategoryPlayAndRecord error:&amp;amp;sessionError];
if(session == nil){
    NSLog(@&quot;Error creating session: %@&quot;, [sessionError description]);
}else{
    [session setActive:YES error:nil];//激活当前session
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果不做初始化，直接使用AudioRecorder的话，录制出来是没有任何声音的，下面几点就是原因，也是它的主要功能：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1.为app选择输入输出的路由 （通过扬声器还是听筒播放）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2.协调音频播放的app之间的关联，以及系统的声音处理&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;3.处理被其他apps打断&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;4.创建一个录音或者播放音乐的任务&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;而这里的参数&lt;code class=&quot;highlighter-rouge&quot;&gt;AVAudioSessionCategoryPlayAndRecord&lt;/code&gt;需要说明一下，可以根据实际情况选择：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* AVAudioSessionCategorySoloAmbient 
  会停止其他程序的音频播放。当设备被设置为静音模式，app也同样被停止
* AVAudioSessionCategoryRecord
  仅用来录音，无法播放音频
* AVAudioSessionCategoryPlayback 
 会停止其它音频播放，并且能在后台播放，锁屏and静音模式下均可
* AVAudioSessionCategoryPlayAndRecord
  能播也能录，播放默认声音是从听筒出来
* AVAudioSessionCategoryAmbient
  app的声音可与其它app共存，但锁屏和静音情况会被停止，除非当前app是唯一播放的app
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;初始化录音器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;录音需要调用AVAudioRecorder，下面代码用于初始化录音器：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSString *docDir = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0];
playName = [NSString stringWithFormat:@&quot;%@/play.aac&quot;,docDir];
//录音设置
recorderSettingsDict =[[NSDictionary alloc] initWithObjectsAndKeys:
                                   [NSNumber 										numberWithInt:kAudioFormatMPEG4AAC],AVFormatIDKey,
                                   [NSNumber numberWithInt:8000],AVSampleRateKey,
                                   [NSNumber numberWithInt:1],AVNumberOfChannelsKey,
                                   AVAudioQualityHigh,AVEncoderAudioQualityKey,
                                   nil];

NSError *error = nil;
//必须真机上测试,模拟器上可能会崩溃
_recorder = [[AVAudioRecorder alloc] initWithURL:[NSURL URLWithString:playName] settings:recorderSettingsDict error:&amp;amp;error];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;先给大家看一下初始化字典里面的参数：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AVFormatIDKey&lt;/code&gt;——音频格式，主要有一下支持格式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kAudioFormatLinearPCM
kAudioFormatMPEG4AAC
kAudioFormatAppleLossless
kAudioFormatAppleMA4
kAudioFormatiLBC
kAudioFormatULaw 选择kAudioFormatLinearPCM会将未压缩的音频流写入到文件中.这种格式保真度最高,不过相应的文件也最大.选择诸如kAudioFormatMPEG4AAC或者kAudioFormatAppleMA4的压缩格式会显著缩小文件,也能保证高质量的音频内容。我这里选择的是kAudioFormatMPEG4AAC,而且安卓和苹果都支持播放。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AVSampleRateKey&lt;/code&gt;——采样率，单位HZ，采样率越小声音质量越低，通常有8000/44100/96000，采样率必须要设为11025才能使转化成mp3格式后不会失真&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AVNumberOfChannelsKey&lt;/code&gt;——声道数，1或2，除非使用外部硬件,否则通常应当创建单声道录音。通常单声道足以满足我们录音功能的需要。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AVEncoderAudioQualityKey&lt;/code&gt;——录音音质，是一个枚举值，这里我选AVAudioQualityHigh中等质量。&lt;/p&gt;

&lt;p&gt;更多参考&lt;a href=&quot;http://www.jianshu.com/p/135ca0deceec&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;开始录制&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;_recorder.meteringEnabled = YES;//设置yes才能监测输入的音量大小，可以用作用户界面反馈
[_recorder record];
volumeTimer = [NSTimer scheduledTimerWithTimeInterval:volumeObserverMargin target:weakSelf selector:@selector(levelTimer:) userInfo:nil repeats:YES];//新建一个计时器用作测量音量大小
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;监测音量&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//输入声音的分贝大小计算
[_recorder updateMeters];
const double ALPHA = 0.05;
double peakPowerForChannel = pow(10, (0.05 * [_recorder peakPowerForChannel:0]));
lowPassResults = ALPHA * peakPowerForChannel + (1.0 - ALPHA) * lowPassResults;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;停止录音&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;_recorder stop];
_recorder = nil;
//结束定时器
[volumeTimer invalidate];
volumeTimer = nil;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;播放本地录音&lt;/h3&gt;

&lt;p&gt;这里分两步操作，一是播放本地音频，二是进行进度监听&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;播放本地音频&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[playerLocal play];
progressTimer = [NSTimer scheduledTimerWithTimeInterval:playerTimeObserverMargin target:self selector:@selector(recorderTimeViewer) userInfo:nil repeats:YES];//新建计时器监听播放进度
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;播放进度监听&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSLog(@&quot;总时长：%f--当前时间点：%f&quot;,_playerLocal.duration,_playerLocal.currentTime);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;播放网络音频&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;_songItem = [[AVPlayerItem alloc]initWithURL:url];
_playerNetwork = [[AVPlayer alloc]initWithPlayerItem:_songItem];
[_playerNetwork play];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;获取网络资源总时长的方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;netAudioTime = CMTimeGetSeconds(_songItem.asset.duration);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;tips&quot;&gt;Tips&lt;/h3&gt;

&lt;p&gt;1..plist文件中加入麦克风请求权限
2.如果需要播放网络音频，添加&lt;code class=&quot;highlighter-rouge&quot;&gt;App Transport Security Settings&lt;/code&gt;下的&lt;code class=&quot;highlighter-rouge&quot;&gt;Allow Arbitrary Loads&lt;/code&gt;并设置为YES
3.如果需要app支持后台播放音频，需要打开&lt;code class=&quot;highlighter-rouge&quot;&gt;Capabilities&lt;/code&gt;下面&lt;code class=&quot;highlighter-rouge&quot;&gt;Background Modes&lt;/code&gt;下面的&lt;code class=&quot;highlighter-rouge&quot;&gt;Audio,AirPlay,and Picture in Picture&lt;/code&gt;选项，但是审核的时候苹果如果认为你没有必要打开这个功能，会被拒哦！
4.不用外接设备录音和播放会声音小，解决办法是播放前加入下面代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSError *audioError = nil;
BOOL success = [audioSession overrideOutputAudioPort:AVAudioSessionPortOverrideSpeaker error:&amp;amp;audioError];
if(!success)
{
NSLog(@&quot;error doing outputaudioportoverride - %@&quot;, [audioError localizedDescription]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;tips-one-more&quot;&gt;Tips one more&lt;/h3&gt;

&lt;p&gt;完整功能的&lt;a href=&quot;https://github.com/JoshPellTan/TJAudioRecorderAndPlayer&quot;&gt;demo&lt;/a&gt;已经更新，分别实现了录音、播放本地录音和播放网络音频的&lt;code class=&quot;highlighter-rouge&quot;&gt;播放&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;暂停&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;继续&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;停止&lt;/code&gt;。&lt;/p&gt;
</description>
        <pubDate>Fri, 19 May 2017 16:08:13 +0800</pubDate>
        <link>/2017/05/%E5%BD%95%E9%9F%B3%E4%B8%8E%E6%92%AD%E6%94%BE%E4%BB%A5%E5%8F%8A%E7%BD%91%E7%BB%9C%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE/</link>
        <guid isPermaLink="true">/2017/05/%E5%BD%95%E9%9F%B3%E4%B8%8E%E6%92%AD%E6%94%BE%E4%BB%A5%E5%8F%8A%E7%BD%91%E7%BB%9C%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE/</guid>
        
        <category>多媒体</category>
        
        <category>音频</category>
        
        <category>录音与播放以及网络音频播放</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>编程思想小觑</title>
        <description>&lt;p&gt;最近在研究RAC,发现编程思想这一个很有趣且有用的东西，就大概研究了一下“链式编程”、“函数式编程”、“响应式编程”几种主要的编程思想，发现对提高代码质量和业务水平很有帮助，下面就挨个介绍一下，也可以直接看我的&lt;a href=&quot;https://github.com/JoshPellTan/ThinkingInPerl.git&quot;&gt;DEMO&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;链式编程&lt;/h3&gt;

&lt;h4 id=&quot;section-1&quot;&gt;&lt;em&gt;思想特点&lt;/em&gt;：&lt;/h4&gt;
&lt;p&gt;是将多个操作（多行代码）通过点号(.)链接在一起成为一句代码,使代码可读性好。类似a(1).b(2).c(3)，方法的返回值是block,block必须有返回值（本身对象），block参数（需要操作的值）&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;&lt;em&gt;代表&lt;/em&gt;：&lt;/h4&gt;
&lt;p&gt;masonry框架、SDAutoLayout框架。&lt;/p&gt;

&lt;h4 id=&quot;demo&quot;&gt;&lt;em&gt;demo&lt;/em&gt;:&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TJChainedModeClass *chainedMode1 = [TJChainedModeClass new];
chainedMode1.addName(@&quot;jackson&quot;).addNickname(@&quot;josh&quot;).addAge(5).addHeadImg(nil);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;chainedMode1.addName(@&quot;jackson&quot;).addNickname(@&quot;josh&quot;).addAge(5).addHeadImg(nil);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;每一步点操作都会返回一个TJChainedModeClass实例对象，这样就可直接调取下一个点属性操作&lt;/p&gt;

&lt;p&gt;这里贴出一个点操作函数，其他的都是类似形式&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef TJChainedModeClass *(^configerString)(NSString *string);//这里的configerString是在.h文件中定义的返回值为本类对象的一个block,放这里方便查看

-(configerString)addName{
    
    if (!_addName) {
        
        __weak typeof(self) weakSelf = self;
        return ^(NSString *string){
            
            weakSelf.name = string;
            return weakSelf;
        };
    }
    
    return _addName;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-3&quot;&gt;响应式编程&lt;/h3&gt;

&lt;h4 id=&quot;section-4&quot;&gt;&lt;em&gt;思想特点&lt;/em&gt;：&lt;/h4&gt;
&lt;p&gt;不需要考虑调用顺序，只需要知道考虑结果，类似于蝴蝶效应，产生一个事件，会影响很多东西，这些事件像流一样的传播出去，然后影响结果，借用面向对象的一句话，万物皆是流。是把操作尽量写成一系列嵌套的函数或者方法调用。
#### &lt;em&gt;代表&lt;/em&gt;：
KVO运用、ReactiveCocoa(也做函数响应式编程)。&lt;/p&gt;

&lt;h4 id=&quot;demo-1&quot;&gt;&lt;em&gt;demo&lt;/em&gt;&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;这里我选用KVO的方式来实现，其实方法很多，可以参考RAC。我这里是给本类的reactNum添加属性监听，有改变外部调用的地方也会执行block，而另外一个属性normalNum的改变则不会引起这种改变
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;.h中代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;assign&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reactNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;assign&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;normalNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reactBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;.m实现:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-(instancetype)init{
    self = [super init];
    
    [self addObserver:self forKeyPath:@&quot;reactNum&quot; options:NSKeyValueObservingOptionNew context:nil];
    
    return self;
}

-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&amp;lt;NSKeyValueChangeKey,id&amp;gt; *)change context:(void *)context{
    
    self.reactBlock(self.normalNum,self.reactNum);
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;调用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-(void)reactProgramming{
    
    //类中的reactNum数值发生变化时，会调用打印方法
    TJReactiveProgrammingClass *reactObj = [TJReactiveProgrammingClass new];
    _reactObj = reactObj;
    
    //[reactObj TJ_addObserver:self forKeyPath:@&quot;reactNum&quot; options:NSKeyValueObservingOptionNew  context:nil];
    reactObj.reactBlock = ^(int normalNum,int reactNum){
        
        NSLog(@&quot;normalNum:%d----reactNum:%d&quot;,normalNum,reactNum);
        
    };
}
//点击测试效果
-(void)touchesBegan:(NSSet&amp;lt;UITouch *&amp;gt; *)touches withEvent:(UIEvent *)event{
    
    _reactObj.reactNum = arc4random() % 100;//改变时会响应
    //_reactObj.normalNum = arc4random() % 100;//改变时不会响应
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-5&quot;&gt;函数式编程&lt;/h3&gt;

&lt;p&gt;什么是函数式编程？函数式编程在iOS中是借由block实现的，通过声明一个block，类似于定义了一个“函数”，再将这个“函数”传递给调用的方法，以此来实现对调用该方法时中间一些过程或者对结果处理的“自定义”，而其内部的其他环节完全不需要暴露给调用者。实际上，调用者也根本不需要知道。&lt;/p&gt;

&lt;p&gt;咱们来看一个例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[self.playBtn mas_makeConstraints:^(MASConstraintMaker *make) {
        make.center.equalTo(self.picView);
        make.width.height.mas_equalTo(50);
    }];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从中可以看出，Masonry中实现自动布局的关键类MASConstraintMaker，他的实例并不是调用者自己创建的，而是通过调用方法mas_makeConstraints:（这里是用了Category），其参数block中的参数传递过来的。&lt;/p&gt;

&lt;p&gt;也就是说，通过mas_makeConstraints:这个方法，我们不需要知道MASConstraintMaker的实例是怎么创建的，也不需要知道具体是怎么实现了给View添加了自动布局，唯一需要的是实现（传递）一个block，在block里按照Masonry的方式指定需要添加的约束就可以了。&lt;/p&gt;

&lt;p&gt;这种实现方式就是本篇要说的函数式编程。&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;&lt;em&gt;函数式编程本质&lt;/em&gt;:&lt;/h4&gt;
&lt;p&gt;就是往方法中传入Block,方法中嵌套Block调用，把代码聚合起来管理
#### &lt;em&gt;函数式编程特点&lt;/em&gt;：
每个方法必须有返回值（本身对象）,把函数或者Block当做参数,block参数（需要操作的值）block返回值（操作结果）
#### &lt;em&gt;代表&lt;/em&gt;：
Masonry、ReactiveCocoa(也做函数响应式编程)。&lt;/p&gt;

&lt;h4 id=&quot;demo-2&quot;&gt;&lt;em&gt;demo&lt;/em&gt;：&lt;/h4&gt;

&lt;p&gt;现在有个类，它有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;NSString *finalString&lt;/code&gt;属性，我不想暴露给外部，在.h文件中我定义一个能传入外部blick的方法，和一个可以操作这个属性值的方法（可能类的内部需要这种操作，但又不想把属性暴露）&lt;/p&gt;

&lt;p&gt;.h代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;makeTool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TJFunctionalProgrammingClass&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TJFunctionalProgrammingClass&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSArray&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strings&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readonly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FunctionalAction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;.m加入一个私有属性：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;finalString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;.m方法实现:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+(NSString *)makeTool:(void (^)(TJFunctionalProgrammingClass *tool))block{
    
    if (block) {
        TJFunctionalProgrammingClass *tool = [[TJFunctionalProgrammingClass alloc]init];
        
        block(tool);
        
        return tool.finalString;
    }
    
    return nil;
}

-(Function)FunctionalAction{
    
    __weak typeof(self) weakself = self;
    return ^(NSArray&amp;lt;NSString *&amp;gt; *strings ){
        
        if (strings.count&amp;gt;0) {
            weakself.finalString = [NSString stringWithFormat:@&quot;FunctionalProgramming + %@&quot;,[strings componentsJoinedByString:@&quot;-&quot;]];
        }else{
            weakself.finalString = @&quot;FunctionalProgramming + nil&quot;;
        }
        
        return weakself;
    };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;调用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSString *str = [TJFunctionalProgrammingClass makeTool:^(TJFunctionalProgrammingClass *tool) {
       
        tool.FunctionalAction(@[@&quot;张三&quot;,@&quot;李四&quot;,@&quot;王五&quot;]);
        
    }];
    
    NSLog(@&quot;functionalProgramming----%@&quot;,str);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 16 May 2017 16:08:13 +0800</pubDate>
        <link>/2017/05/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E5%B0%8F%E8%A7%91/</link>
        <guid isPermaLink="true">/2017/05/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E5%B0%8F%E8%A7%91/</guid>
        
        <category>编程思想</category>
        
        <category>链式编程</category>
        
        <category>响应式编程</category>
        
        <category>函数式编程</category>
        
        <category>编程思想小觑</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>iOS启动速度的优化</title>
        <description>&lt;p&gt;最近我们APP安卓端做了个小优化，将网络框架做了更换，并且减少了启动时候的一些初始化。然后CTO拿着一个安卓手机过来对我说，安卓优化后比你们快多了。啥？不可能，苹果手机大几千呢！玩儿呢？！不服，下班拿了一个安卓2000多块的手机跟我的苹果手机做了一下APP打开比较，苹果完败！必须不服，咱也要优化打开速度！&lt;/p&gt;

&lt;p&gt;很多地方说测一下&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;方法到&lt;code class=&quot;highlighter-rouge&quot;&gt;- (BOOL)Application:(UIApplication *)Application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&lt;/code&gt;方法的时间就是APP的打开时间了，虽然能一定程度上反映这个指标，但是不严谨。&lt;/p&gt;

&lt;p&gt;t(App总启动时间) = t1(main()之前的加载时间) + t2(main()之后的加载时间)。 t1 = 系统dylib(动态链接库)和自身App可执行文件的加载； t2 = main方法执行之后到AppDelegate类中的- (BOOL)Application:(UIApplication *)Application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions方法执行结束前这段时间，主要是构建第一个界面，并完成渲染展示。&lt;/p&gt;

&lt;h3 id=&quot;main&quot;&gt;main()调用之前的加载过程&lt;/h3&gt;

&lt;p&gt;App开始启动后， 系统首先加载可执行文件（自身App的所有.o文件的集合），然后加载动态链接库dyld，dyld是一个专门用来加载动态链接库的库。 执行从dyld开始，dyld从可执行文件的依赖开始, 递归加载所有的依赖动态链接库。 
动态链接库包括：iOS 中用到的所有系统 framework，加载OC runtime方法的libobjc，系统级别的libSystem，例如libdispatch(GCD)和libsystem_blocks (Block)。&lt;/p&gt;

&lt;p&gt;其实无论对于系统的动态链接库还是对于App本身的可执行文件而言，他们都算是image（镜像），而每个App都是以image(镜像)为单位进行加载的，那么image究竟包括哪些呢？&lt;/p&gt;

&lt;h3 id=&quot;image&quot;&gt;什么是image&lt;/h3&gt;

&lt;p&gt;1.executable可执行文件 比如.o文件。 
2.dylib 动态链接库 framework就是动态链接库和相应资源包含在一起的一个文件夹结构。 
3.bundle 资源文件 只能用dlopen加载，不推荐使用这种方式加载。&lt;/p&gt;

&lt;p&gt;除了我们App本身的可行性文件，系统中所有的framework比如UIKit、Foundation等都是以动态链接库的方式集成进App中的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;系统使用动态链接有几点好处&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;代码共用&lt;/strong&gt;:很多程序都动态链接了这些 lib，但它们在内存和磁盘中中只有一份。 易于维护：由于被依赖的 lib 是程序执行时才链接的，所以这些 lib 很容易做更新，比如libSystem.dylib 是 libSystem.B.dylib 的替身，哪天想升级直接换成libSystem.C.dylib 然后再替换替身就行了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;减少可执行文件体积&lt;/strong&gt;:相比静态链接，动态链接在编译时不需要打进去，所以可执行文件的体积要小很多。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://ofnft8t2g.bkt.clouddn.com/wikiimage0.png&quot; width=&quot;400&quot; height=&quot;400&quot; alt=&quot;photos&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上所示，不同进程之间共用系统dylib的_TEXT区，但是各自维护对应的_DATA区。&lt;/p&gt;

&lt;p&gt;所有动态链接库和我们App中的静态库.a和所有类文件编译后的.o文件最终都是由dyld(the dynamic link editor)即Apple的动态链接器来加载到内存中。每个image都是由一个叫做ImageLoader的类来负责加载（一一对应），那么ImageLoader又是什么呢？&lt;/p&gt;

&lt;h3 id=&quot;imageloader&quot;&gt;什么是ImageLoader&lt;/h3&gt;

&lt;p&gt;image 表示一个二进制文件(可执行文件或 so 文件)，里面是被编译过的符号、代码等，所以 ImageLoader 作用是将这些文件加载进内存，且每一个文件对应一个ImageLoader实例来负责加载。 
两步走： 在程序运行时它先将动态链接的 image 递归加载 (也就是上面测试栈中一串的递归调用的时刻)。 再从可执行文件 image 递归加载所有符号。&lt;/p&gt;

&lt;p&gt;所有这些都发生在我们真正的main函数执行前。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;动态链接库加载的具体流程&lt;/h3&gt;

&lt;p&gt;动态链接库的加载步骤具体分为5步：&lt;/p&gt;

&lt;h4 id=&quot;load-dylibs-image-&quot;&gt;&lt;strong&gt;一.load dylibs image&lt;/strong&gt; 读取库镜像文件&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;在每个动态库的加载过程中，dyld需要：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;1.分析所依赖的动态库
2.找到动态库的mach-o文件
3.打开文件
4.验证文件
5.在系统核心注册文件签名
6.对动态库的每一个segment调用mmap()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通常的，一个App需要加载100到400个dylibs， 但是其中的系统库被优化，可以很快的加载。 针对这一步骤的优化有：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1.减少非系统库的依赖
2.合并非系统库
3.使用静态资源，比如把代码加入主程&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;rebase-image&quot;&gt;&lt;strong&gt;Rebase image&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;由于ASLR(address space layout randomization)的存在，可执行文件和动态链接库在虚拟内存中的加载地址每次启动都不固定，所以需要这2步来修复镜像中的资源指针，来指向正确的地址。 rebase修复的是指向当前镜像内部的资源指针； 而bind指向的是镜像外部的资源指针。 
rebase步骤先进行，需要把镜像读入内存，并以page为单位进行加密验证，保证不会被篡改，所以这一步的瓶颈在IO。bind在其后进行，由于要查询符号表，来指向跨镜像的资源，加上在rebase阶段，镜像已被读入和加密验证，所以这一步的瓶颈在于CPU计算。 
通过命令行可以查看相关的资源指针:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;xcrun dyldinfo -rebase -bind -lazy_bind myApp.App/myApp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;优化该阶段的关键在于减少__DATA segment中的指针数量。我们可以优化的点有：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1.减少Objc类数量， 减少selector数量
2.减少C++虚函数数量
3.转而使用swift stuct（其实本质上就是为了减少符号的数量）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;bind-image&quot;&gt;&lt;strong&gt;Bind image&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;上部已连带讲解&lt;/p&gt;

&lt;h4 id=&quot;objc-setup&quot;&gt;&lt;strong&gt;Objc setup&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;这一步主要工作是:
&amp;gt;1.注册Objc类 (class registration)
&amp;gt;2.把category的定义插入方法列表 (category registration)
&amp;gt;3.保证每一个selector唯一 (selctor uniquing)
由于之前2步骤的优化，这一步实际上没有什么可做的。&lt;/p&gt;

&lt;h4 id=&quot;initializers&quot;&gt;&lt;strong&gt;initializers&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;以上三步属于静态调整(fix-up)，都是在修改__DATA segment中的内容，而这里则开始动态调整，开始在堆和堆栈中写入内容。 在这里的工作有：
&amp;gt;1.Objc的+load()函数
&amp;gt;2.C++的构造函数属性函数 形如attribute((constructor)) void DoSomeInitializationWork()
&amp;gt;3.非基本类型的C++静态全局变量的创建(通常是类或结构体)(non-trivial initializer) 比如一个全局静态结构体的构建，如果在构造函数中有繁重的工作，那么会拖慢启动速度
Objc的load函数和C++的静态构造函数采用由底向上的方式执行，来保证每个执行的方法，都可以找到所依赖的动态库。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ofnft8t2g.bkt.clouddn.com/wikiimage1.png&quot; width=&quot;300&quot; height=&quot;200&quot; alt=&quot;photos&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图是在自定义的类XXViewController的+load方法断点的调用堆栈，清楚的看到整个调用栈和顺序：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1.dyld 开始将程序二进制文件初始化
2.交由 ImageLoader 读取 image，其中包含了我们的类、方法等各种符号
3.由于 runtime 向 dyld 绑定了回调，当 image 加载到内存后，dyld 会通知 runtime 进行处理
4.runtime 接手后调用 mapimages 做解析和处理，接下来 loadimages 中调用 callloadmethods 方法，遍历所有加载进来的 Class，按继承层级依次调用 Class 的 +load 方法和其 Category 的 +load 方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;至此，可执行文件中和动态库所有的符号(Class，Protocol，Selector，IMP，…)都已经按格式成功加载到内存中，被 runtime 所管理，再这之后，runtime 的那些方法(动态添加 Class、swizzle 等等才能生效)。&lt;/p&gt;

&lt;p&gt;整个事件由 dyld 主导，完成运行环境的初始化后，配合 ImageLoader 将二进制文件按格式加载到内存， 动态链接依赖库，并由 runtime 负责加载成 objc 定义的结构，所有初始化工作结束后，dyld 调用真正的 main 函数。&lt;/p&gt;

&lt;p&gt;如果程序刚刚被运行过，那么程序的代码会被dyld缓存，因此即使杀掉进程再次重启加载时间也会相对快一点，如果长时间没有启动或者当前dyld的缓存已经被其他应用占据，那么这次启动所花费的时间就要长一点，这就分别是热启动和冷启动的概念，如下图所示:&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ofnft8t2g.bkt.clouddn.com/wikiimage2.png&quot; width=&quot;300&quot; height=&quot;200&quot; alt=&quot;photos&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;main-1&quot;&gt;main()函数之前的加载时间衡量&lt;/h3&gt;

&lt;p&gt;苹果官方提供了一种方法，那就是在真机调试的时候勾选dyldPRINTSTATISTICS选项。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ofnft8t2g.bkt.clouddn.com/wikiimage3.png&quot; width=&quot;500&quot; height=&quot;300&quot; alt=&quot;photos&quot; /&gt;&lt;/p&gt;

&lt;p&gt;会得到如下形式的输出:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ofnft8t2g.bkt.clouddn.com/wikiimage4.png&quot; width=&quot;400&quot; height=&quot;300&quot; alt=&quot;photos&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于系统级别的动态链接库，因为苹果做了优化，所以耗时并不多，在这个awesome的例子中，自身App中的代码占用了整体时间的94.2% 我们应用中一次典型的Log如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ofnft8t2g.bkt.clouddn.com/wikiimage5.png&quot; width=&quot;500&quot; height=&quot;300&quot; alt=&quot;photos&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由此可见，最多的用时还是在image加载和OC类的初始化，共占用总时长的79.3%，精简framework的引入和OC类有优化的空间。&lt;/p&gt;

&lt;p&gt;总结一下：对于main()调用之前的耗时我们可以优化的点有：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1.减少不必要的framework，因为动态链接比较耗时
2.check framework应当设为optional和required，如果该framework在当前App支持的所有iOS系统版本都存在，那么就设为required，否则就设为optional，因为optional会有些额外的检查
3.合并或者删减一些OC类，关于清理项目中没用到的类，使用工具AppCode代码检查功能，查到当前项目中没有用到的类如下：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://ofnft8t2g.bkt.clouddn.com/wikiimage6_new.png&quot; width=&quot;500&quot; height=&quot;350&quot; alt=&quot;photos&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后处理步骤大概如下：
a.删减一些无用的静态变量
b.删减没有被调用到或者已经废弃的方法
方法见：
&amp;gt;http://stackoverflow.com/questions/35233564/how-to-find-unused-code-in-xcode-7
&amp;gt;https://developer.Apple.com/library/ios/documentation/ToolsLanguages/Conceptual/Xcode_Overview/CheckingCodeCoverage.html
c.将不必须在+load方法中做的事情延迟到+initialize中
d.尽量不要用C++虚函数(创建虚函数表有开销)&lt;/p&gt;

&lt;h3 id=&quot;main-2&quot;&gt;main函数之后加载时间优化记录&lt;/h3&gt;

&lt;p&gt;NSUserDefaults是否是瓶颈?
苹果官方文档提到NSUserDefaults加载的时候是整个plist配置文件全部load到内存中，但是测试结果显示并不会。 通过符号断点+[NSUserDefaults standardUserDefaults]确定最早一次的+load()从执行到结束耗时1.8ms，可见NSUserDefaults的初始化仅耗时1.8ms，并不是启动耗时的瓶颈。&lt;/p&gt;

&lt;p&gt;为了找到瓶颈，在启动之后的didFinishLauhcning方法开始执行到首页列表页的WZMainViewController的viewDidAppear方法，几乎每个可能比较耗时的流程进行拆分和统计，得到统计数据之后发现： 主要耗时在首页UI构造和渲染(storyboard加载，tabBar/topBar渲染，开屏广告加载/cell注册/日志模块初始化这几个步骤)。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;&lt;strong&gt;具体优化点&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;1.纯代码方式而不是storyboard加载首页UI。
2.对didFinishLaunching里的函数考虑能否挖掘可以延迟加载或者懒加载，需要与各个业务方pm和rd共同check 对于一些已经下线的业务，删减冗余代码。对于一些与UI展示无关的业务，如微博认证过期检查、图片最大缓存空间设置等做延迟加载
3.对实现了+load()方法的类进行分析，尽量将load里的代码延后调用。
4.上面统计数据显示展示feed的导航控制器页面(WZMainViewController)比较耗时，对于viewDidLoad以及viewWillAppear方法中尽量去尝试少做，晚做，不做。&lt;/p&gt;

</description>
        <pubDate>Mon, 15 May 2017 16:08:13 +0800</pubDate>
        <link>/2017/05/iOS%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E7%9A%84%E4%BC%98%E5%8C%96/</link>
        <guid isPermaLink="true">/2017/05/iOS%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E7%9A%84%E4%BC%98%E5%8C%96/</guid>
        
        <category>优化</category>
        
        <category>启动速度</category>
        
        <category>iOS启动速度的优化</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>iOS的https认证(二)</title>
        <description>&lt;p&gt;上篇文章讲了iOS和服务器如何从官方机构请求CA证书进行https配置，这里我们来讲讲如何自建证书来配置https，针对AFNetworking网络框架和苹果自带框架NSURLConnection。&lt;/p&gt;

&lt;h3 id=&quot;afnetworking&quot;&gt;AFNetworking&lt;/h3&gt;

&lt;p&gt;1.把服务器给你的自签证的证书放入bundle一般是.cer文件&lt;/p&gt;

&lt;p&gt;2.创建afnnetworking 安全策略对象,并设置发起请求manager的安全策略属性.设置了安全策略属性,afnnetworking会自动扫描bundl里的证书.&lt;/p&gt;

&lt;p&gt;3.最坑的是 iOS9新出的App Transport Security 也就是要我们把所有请求从 HTTP改成HTTPS的家伙, 它竟然不认自签证的证书. 苹果大爷难道真是土豪惯了,以为我们开发者都会买ca的证书吗. 解决办法就是那里还是要设置在Info.plist中添加NSAppTransportSecurity类型Dictionary在NSAppTransportSecurity下添加NSAllowsArbitraryLoads类型 Boolean,值设为YES&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSString *cerPath = [[NSBundle mainBundle] pathForResource:@&quot;https&quot; ofType:@&quot;cer&quot;];

NSData *certData = [NSData dataWithContentsOfFile:cerPath];

//AFSSLPinningModeCertificate 使用证书验证模式

AFSecurityPolicy *securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate];

//allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO

//如果是需要验证自建证书，需要设置为YES

securityPolicy.allowInvalidCertificates = YES;

securityPolicy.validatesDomainName = NO;

NSSet *set = [[NSSet alloc] initWithObjects:certData, nil];

securityPolicy.pinnedCertificates = set;

AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];

manager.requestSerializer = [AFJSONRequestSerializer serializer];

manager.responseSerializer=[AFJSONResponseSerializer serializer];

manager.responseSerializer.acceptableContentTypes = [manager.responseSerializer.acceptableContentTypes setByAddingObject:@&quot;text/html&quot;];

[manager setSecurityPolicy:securityPolicy];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;nsurlconnection&quot;&gt;NSURLConnection&lt;/h3&gt;

&lt;p&gt;NSURLConnection 使用自签证证书支持HTTPS,只需要在实现NSURLConnection的代理方法即可. 参考&lt;a href=&quot;https://gist.github.com/JacksonTian/5855751&quot;&gt;GitHub JacksonTian&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (BOOL)connection:(NSURLConnection *)connection canAuthenticateAgainstProtectionSpace:(NSURLProtectionSpace *)protectionSpace{

    return [protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust];
}

- (void)connection:(NSURLConnection *)connection didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge
{
    static CFArrayRef certs;
    if (!certs) {
        //创建证书data
        NSData*certData =[NSData dataWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@&quot;HTTPS&quot; ofType:@&quot;cer&quot;]];

        SecCertificateRef rootcert = SecCertificateCreateWithData(kCFAllocatorDefault,CFBridgingRetain(certData));
        const void *array[1] = { rootcert };
        certs = CFArrayCreate(NULL, array, 1, &amp;amp;kCFTypeArrayCallBacks);
//        CFRelease(rootcert);    // for completeness, really does not matter
    }

    SecTrustRef trust = [[challenge protectionSpace] serverTrust];
    int err;
    SecTrustResultType trustResult = 0;
    err = SecTrustSetAnchorCertificates(trust, certs);
    if (err == noErr) {
        err = SecTrustEvaluate(trust,&amp;amp;trustResult);
    }
//    BOOL trusted = (err == noErr) &amp;amp;&amp;amp; ((trustResult == kSecTrustResultProceed)||(trustResult == kSecTrustResultConfirm) || (trustResult == kSecTrustResultUnspecified));
    BOOL trusted = (err == noErr) &amp;amp;&amp;amp; ((trustResult == kSecTrustResultProceed) || (trustResult == kSecTrustResultUnspecified));

    if (trusted) {

        [challenge.sender useCredential:[NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust] forAuthenticationChallenge:challenge];
    }
    else{

        [challenge.sender cancelAuthenticationChallenge:challenge];
    }

//CFRelease(trust);

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Thu, 11 May 2017 22:08:13 +0800</pubDate>
        <link>/2017/05/iOS%E7%9A%84https%E8%AE%A4%E8%AF%81-%E4%BA%8C/</link>
        <guid isPermaLink="true">/2017/05/iOS%E7%9A%84https%E8%AE%A4%E8%AF%81-%E4%BA%8C/</guid>
        
        <category>网络</category>
        
        <category>https</category>
        
        <category>iOS的https认证(二)</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>iOS的https认证(一)</title>
        <description>&lt;p&gt;苹果官方在2017年年初要求APP必须配置https（这里可以从&lt;a href=&quot;https://onevcat.com/2016/06/ios-10-ats/&quot;&gt;喵神的博客&lt;/a&gt;了解），可是后来不知啥原因搁浅了，但这个东西终究还是要做的。不然随便一个抓包工具（charles等）随随便便就能抓到你所请求的数据，这些数据如果是明码的后果很严重（不是指明文），可以通过这些数据来判定服务端部署的数据接口，更能够嗅探到服务端的漏洞。而现在绝大部分APP使用的都是AFNetworking这个网络框架，我们就对AFNetworking如何配置https来做探讨。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;服务器端如何实现https&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这里就不在赘述https的原理了，网上有很多介绍的文章。https之所以安全是因为它采用了SSL/TLS协议的公钥加密法，其运行的基本流程是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;客户端向服务器端索要并验证公钥；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;双方协商生成”对话密钥”；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;双方采用”对话密钥”进行加密通信。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中，第1和2步被称为握手阶段。握手阶段的细节这里就不赘述，我们只需要知道，通过握手阶段，客户端和服务器端主要交换了3个信息：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;1，数字证书。该信息是我们进行开发需要关注的！数字证书包含了公钥等信息，一般由服务器发给客户端，接收方通过验证这个证书是不是由信赖的CA签发，或者与本地的证书相对比，来判断证书是否可信；假如需要双向验证，则服务器和客户端都需要发送数字证书给对方验证；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2，3个随机数。3个随机数是用于生成对话密钥的，我们不需要关心这细节；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;3，加密通信协议。客户端和服务器端通信需要采取同样的加密通信协议，我们也不需要太关注。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以咱们需要做的就是拿到数字证书&lt;a href=&quot;http://kb.cnblogs.com/page/194742/&quot;&gt;数字证书及CA&lt;/a&gt;，这里有两种方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;向官方CA认证机构申请证书&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;自建证书，配置给服务器&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一种方法是最优的，建立网站的话，直接就会被信任。而服务器作为移动端app的服务器时，也不需要为ATS做过多的适配（正是我所需要积累知识的方向）。虽然说权威的机构认证都是需要钱的，但是如今也不乏存在免费的第三方认证机构。&lt;/p&gt;

&lt;p&gt;第二种方法虽然对于app和服务器间的通讯是可行的，但是如果从网站打开链接时会弹出一个警告提醒，提醒这是一个不受信任的网站，需要用户手动设置信任才行，这种体验会让用户感觉网站不安全。而客户端配置时需要将info.plist文件中将App Transport Security Settings中的Allow Arbitrary Loads设置为YES或者在App Transport Security Settings下添加白名单（新增Exception Domains选项，将自己服务器的域名放进去），这里我要说的是许多人不管三七二十一是直接将Allow Arbitrary Loads设置为YES，这种设置会信任其他所有的http请求，相当于https白做了，所以后者才是可取的。&lt;/p&gt;

&lt;p&gt;这里有一个方法可以快速检测服务器的https特性是否符合ATS的要求：
控制台输入&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nscurl --ats-diagnostics --verbose https://example.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个&lt;code class=&quot;highlighter-rouge&quot;&gt;https://example.com&lt;/code&gt;就是你想检测的域名，咱们来试试知乎&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nscurl --ats-diagnostics --verbose https://www.zhihu.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Starting ATS Diagnostics

Configuring ATS Info.plist keys and displaying the result of HTTPS loads to https://www.zhihu.com.
A test will &quot;PASS&quot; if URLSession:task:didCompleteWithError: returns a nil error.
================================================================================

Default ATS Secure Connection

---
ATS Default Connection
ATS Dictionary:
{
}
Result : PASS
---

================================================================================

Allowing Arbitrary Loads

---
Allow All Loads
ATS Dictionary:
{
    NSAllowsArbitraryLoads = true;
}
Result : PASS
---

================================================================================

Configuring TLS exceptions for www.zhihu.com

---
TLSv1.2
ATS Dictionary:
{
    NSExceptionDomains =     {
        &quot;www.zhihu.com&quot; =         {
            NSExceptionMinimumTLSVersion = &quot;TLSv1.2&quot;;
        };
    };
}
Result : PASS
---

---
TLSv1.1
ATS Dictionary:
{
    NSExceptionDomains =     {
        &quot;www.zhihu.com&quot; =         {
            NSExceptionMinimumTLSVersion = &quot;TLSv1.1&quot;;
        };
    };
}
Result : PASS
---

---
TLSv1.0
ATS Dictionary:
{
    NSExceptionDomains =     {
        &quot;www.zhihu.com&quot; =         {
            NSExceptionMinimumTLSVersion = &quot;TLSv1.0&quot;;
        };
    };
}
Result : PASS
---

================================================================================

Configuring PFS exceptions for www.zhihu.com

---
Disabling Perfect Forward Secrecy
ATS Dictionary:
{
    NSExceptionDomains =     {
        &quot;www.zhihu.com&quot; =         {
            NSExceptionRequiresForwardSecrecy = false;
        };
    };
}
Result : PASS
---

================================================================================

Configuring PFS exceptions and allowing insecure HTTP for www.zhihu.com

---
Disabling Perfect Forward Secrecy and Allowing Insecure HTTP
ATS Dictionary:
{
    NSExceptionDomains =     {
        &quot;www.zhihu.com&quot; =         {
            NSExceptionAllowsInsecureHTTPLoads = true;
            NSExceptionRequiresForwardSecrecy = false;
        };
    };
}
Result : PASS
---

================================================================================

Configuring TLS exceptions with PFS disabled for www.zhihu.com

---
TLSv1.2 with PFS disabled
ATS Dictionary:
{
    NSExceptionDomains =     {
        &quot;www.zhihu.com&quot; =         {
            NSExceptionMinimumTLSVersion = &quot;TLSv1.2&quot;;
            NSExceptionRequiresForwardSecrecy = false;
        };
    };
}
Result : PASS
---

---
TLSv1.1 with PFS disabled
ATS Dictionary:
{
    NSExceptionDomains =     {
        &quot;www.zhihu.com&quot; =         {
            NSExceptionMinimumTLSVersion = &quot;TLSv1.1&quot;;
            NSExceptionRequiresForwardSecrecy = false;
        };
    };
}
Result : PASS
---

---
TLSv1.0 with PFS disabled
ATS Dictionary:
{
    NSExceptionDomains =     {
        &quot;www.zhihu.com&quot; =         {
            NSExceptionMinimumTLSVersion = &quot;TLSv1.0&quot;;
            NSExceptionRequiresForwardSecrecy = false;
        };
    };
}
Result : PASS
---

================================================================================

Configuring TLS exceptions with PFS disabled and insecure HTTP allowed for www.zhihu.com

---
TLSv1.2 with PFS disabled and insecure HTTP allowed
ATS Dictionary:
{
    NSExceptionDomains =     {
        &quot;www.zhihu.com&quot; =         {
            NSExceptionAllowsInsecureHTTPLoads = true;
            NSExceptionMinimumTLSVersion = &quot;TLSv1.2&quot;;
            NSExceptionRequiresForwardSecrecy = false;
        };
    };
}
Result : PASS
---

---
TLSv1.1 with PFS disabled and insecure HTTP allowed
ATS Dictionary:
{
    NSExceptionDomains =     {
        &quot;www.zhihu.com&quot; =         {
            NSExceptionAllowsInsecureHTTPLoads = true;
            NSExceptionMinimumTLSVersion = &quot;TLSv1.1&quot;;
            NSExceptionRequiresForwardSecrecy = false;
        };
    };
}
Result : PASS
---

---
TLSv1.0 with PFS disabled and insecure HTTP allowed
ATS Dictionary:
{
    NSExceptionDomains =     {
        &quot;www.zhihu.com&quot; =         {
            NSExceptionAllowsInsecureHTTPLoads = true;
            NSExceptionMinimumTLSVersion = &quot;TLSv1.0&quot;;
            NSExceptionRequiresForwardSecrecy = false;
        };
    };
}
Result : PASS
---
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到知乎在所有测试中的结果都是PASS，知乎对用户的信息安全保护工作做得还是不错的，赞！自己的服务器配置好了https后也可以用这个来进行尝试。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;iOS端如何实现https&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;基于对HTTPS运行机制的理解，我们知道，在iOS客户端实现与服务器的https通信，前提条件是你的服务器是一个提供了https的服务器。如果前提得以满足，那么iOS客户端就需要向服务器发出请求索要公钥，而后验证公钥，然后进行握手，最后开始加密通信。那么，具体怎么做呢？难倒这些都需要我自己实现吗？肯定不是的，这种基础性工作，苹果早就做好了，著名的第三方库AFNetworking也早就做好了。&lt;/p&gt;

&lt;p&gt;1.删除掉info.plist文件中App Transport Security Settings及其子项Allow Arbitrary Loads，让ATS恢复到默认状态。&lt;/p&gt;

&lt;p&gt;2.修改主域名为项目的https域名&lt;/p&gt;

&lt;p&gt;由此可知，对于符合ATS要求的HTTPS服务器，在iOS端不需要对ATS做特殊的适配就能和HTTPS服务器进行通信。而要符合ATS要求，则需要老老实实地创建证书请求，然后到权威机构认证，随之配置到服务器。是不是超级简单？&lt;/p&gt;

&lt;p&gt;对于自建证书的方法和配置下篇文章再讲。&lt;/p&gt;

</description>
        <pubDate>Thu, 11 May 2017 16:08:13 +0800</pubDate>
        <link>/2017/05/iOS%E7%9A%84https%E8%AE%A4%E8%AF%81-%E4%B8%80/</link>
        <guid isPermaLink="true">/2017/05/iOS%E7%9A%84https%E8%AE%A4%E8%AF%81-%E4%B8%80/</guid>
        
        <category>网络</category>
        
        <category>https</category>
        
        <category>iOS的https认证(一)</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>iOS的静态与动态内存分析</title>
        <description>&lt;p&gt;近段时间app处于优化阶段，发现在一些列表页面查看数据久一点就会出现莫名其妙的崩溃。连上Xcode一查，也不是必现，但频率比较高，而且没有崩溃提示，是手机和Xcode直接断开连接。再看着性能指示进行操作，果不其然，每次内存飙升到一定程度就会崩溃。一个app想要走向成熟，这种问题必须解决，这里就需要谈到iOS的静态与动态内存分析&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;静态内存分析&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;优点&lt;/code&gt;：分析内存非常快，已经可以对整个项目的内存进行分析。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;缺点&lt;/code&gt;：不运行程序，直接对代码进行分析。根据代码的上下文语法结构，看语法是否有问题。（不够准确，但是如果通过静态内存分析，有提示出现了内存泄露，需要通过分析代码上下文查看是否有内存泄露）&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;快捷键&lt;/code&gt;：command +shift +b&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;进行方式&lt;/code&gt;：Product – &amp;gt; Analyze&lt;/p&gt;

&lt;h3 id=&quot;instrument&quot;&gt;动态内存分析（Instrument）&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;优点&lt;/code&gt;：真正运行起来的程序，并且可以对某一个操作来具体分析，当用户做了某一个操作时，该操作是否产生了内存泄露（分厂准确，如果提示有内存泄露，基本可以说明代码有问题）&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;缺点&lt;/code&gt;：分析速度非常慢，需要一步一步来分析代码是否有问题，切可能在分析过程中有遗漏代码。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;进行方式&lt;/code&gt;：Product –&amp;gt; Profile –&amp;gt;Leaks –&amp;gt; 选择想要运行的项目 –&amp;gt; Record&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/266345-5cc73c61f7ae76c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300&quot; width=&quot;300&quot; height=&quot;200&quot; alt=&quot;photos&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/266345-28c2b43923fe13da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300&quot; width=&quot;400&quot; height=&quot;200&quot; alt=&quot;photos&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/266345-48b146c5196c07d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300&quot; width=&quot;400&quot; height=&quot;200&quot; alt=&quot;photos&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样就可以开始动态检测一个项目是否存在内存泄露了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：我们需要进行操作让系统不断去执行所要检测的代码是否存在内存泄露。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果有内存泄露的情况就会出现下图情况&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/266345-be4e19b457a6baf9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300&quot; width=&quot;400&quot; height=&quot;200&quot; alt=&quot;photos&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里我们在右侧 Stack Trace 拦下点击我们所创建的方法，也就是带人像的方法，这样就能定位到泄露的位置了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/266345-7fc50ba21788fbcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300&quot; width=&quot;300&quot; height=&quot;50&quot; alt=&quot;photos&quot; /&gt;&lt;/p&gt;

&lt;p&gt;选中某一个泄露位置，之后点击右上角 Xcode 的图标直接回到 Xcode 代码中进行修改，这样我们动态内存分析就完成了&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/266345-5812ead6f94787d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300&quot; width=&quot;300&quot; height=&quot;100&quot; alt=&quot;photos&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：我们可能会看到这样的情况， All Heap Allocations 是程序真实的内存分配情况，All Anonymous VM则是系统为程序分配的虚拟内存，为的就是当程序有需要的时候，能够及时为程序提供足够的内存空间，而不会现用现创建&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/266345-34d339d54700e6a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300&quot; width=&quot;300&quot; height=&quot;30&quot; alt=&quot;photos&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 09 May 2017 16:08:13 +0800</pubDate>
        <link>/2017/05/iOS%E7%9A%84%E9%9D%99%E6%80%81%E4%B8%8E%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/</link>
        <guid isPermaLink="true">/2017/05/iOS%E7%9A%84%E9%9D%99%E6%80%81%E4%B8%8E%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/</guid>
        
        <category>优化</category>
        
        <category>内存</category>
        
        <category>iOS的静态与动态内存分析</category>
        
        
        <category>study</category>
        
      </item>
    
  </channel>
</rss>
